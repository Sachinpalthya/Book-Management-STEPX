
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Book
 * 
 */
export type Book = $Result.DefaultSelection<Prisma.$BookPayload>
/**
 * Model Subject
 * 
 */
export type Subject = $Result.DefaultSelection<Prisma.$SubjectPayload>
/**
 * Model BookSubject
 * 
 */
export type BookSubject = $Result.DefaultSelection<Prisma.$BookSubjectPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model QRCode
 * 
 */
export type QRCode = $Result.DefaultSelection<Prisma.$QRCodePayload>
/**
 * Model Redirect
 * 
 */
export type Redirect = $Result.DefaultSelection<Prisma.$RedirectPayload>
/**
 * Model AcademicYear
 * 
 */
export type AcademicYear = $Result.DefaultSelection<Prisma.$AcademicYearPayload>
/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model WhitelistedUrl
 * 
 */
export type WhitelistedUrl = $Result.DefaultSelection<Prisma.$WhitelistedUrlPayload>
/**
 * Model BlockedUrl
 * 
 */
export type BlockedUrl = $Result.DefaultSelection<Prisma.$BlockedUrlPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.book`: Exposes CRUD operations for the **Book** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Books
    * const books = await prisma.book.findMany()
    * ```
    */
  get book(): Prisma.BookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subject`: Exposes CRUD operations for the **Subject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subjects
    * const subjects = await prisma.subject.findMany()
    * ```
    */
  get subject(): Prisma.SubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookSubject`: Exposes CRUD operations for the **BookSubject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookSubjects
    * const bookSubjects = await prisma.bookSubject.findMany()
    * ```
    */
  get bookSubject(): Prisma.BookSubjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qRCode`: Exposes CRUD operations for the **QRCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QRCodes
    * const qRCodes = await prisma.qRCode.findMany()
    * ```
    */
  get qRCode(): Prisma.QRCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.redirect`: Exposes CRUD operations for the **Redirect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redirects
    * const redirects = await prisma.redirect.findMany()
    * ```
    */
  get redirect(): Prisma.RedirectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.academicYear`: Exposes CRUD operations for the **AcademicYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicYears
    * const academicYears = await prisma.academicYear.findMany()
    * ```
    */
  get academicYear(): Prisma.AcademicYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whitelistedUrl`: Exposes CRUD operations for the **WhitelistedUrl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhitelistedUrls
    * const whitelistedUrls = await prisma.whitelistedUrl.findMany()
    * ```
    */
  get whitelistedUrl(): Prisma.WhitelistedUrlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockedUrl`: Exposes CRUD operations for the **BlockedUrl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUrls
    * const blockedUrls = await prisma.blockedUrl.findMany()
    * ```
    */
  get blockedUrl(): Prisma.BlockedUrlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserRole: 'UserRole',
    Permission: 'Permission',
    Book: 'Book',
    Subject: 'Subject',
    BookSubject: 'BookSubject',
    Notification: 'Notification',
    Chapter: 'Chapter',
    QRCode: 'QRCode',
    Redirect: 'Redirect',
    AcademicYear: 'AcademicYear',
    Branch: 'Branch',
    WhitelistedUrl: 'WhitelistedUrl',
    BlockedUrl: 'BlockedUrl',
    Settings: 'Settings'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userRole" | "permission" | "book" | "subject" | "bookSubject" | "notification" | "chapter" | "qRCode" | "redirect" | "academicYear" | "branch" | "whitelistedUrl" | "blockedUrl" | "settings"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Book: {
        payload: Prisma.$BookPayload<ExtArgs>
        fields: Prisma.BookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findFirst: {
            args: Prisma.BookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          findMany: {
            args: Prisma.BookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          create: {
            args: Prisma.BookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          createMany: {
            args: Prisma.BookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          delete: {
            args: Prisma.BookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          update: {
            args: Prisma.BookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          deleteMany: {
            args: Prisma.BookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>[]
          }
          upsert: {
            args: Prisma.BookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookPayload>
          }
          aggregate: {
            args: Prisma.BookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBook>
          }
          groupBy: {
            args: Prisma.BookGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookCountArgs<ExtArgs>
            result: $Utils.Optional<BookCountAggregateOutputType> | number
          }
        }
      }
      Subject: {
        payload: Prisma.$SubjectPayload<ExtArgs>
        fields: Prisma.SubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findFirst: {
            args: Prisma.SubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          findMany: {
            args: Prisma.SubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          create: {
            args: Prisma.SubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          createMany: {
            args: Prisma.SubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          delete: {
            args: Prisma.SubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          update: {
            args: Prisma.SubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          deleteMany: {
            args: Prisma.SubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>[]
          }
          upsert: {
            args: Prisma.SubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubjectPayload>
          }
          aggregate: {
            args: Prisma.SubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubject>
          }
          groupBy: {
            args: Prisma.SubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubjectCountArgs<ExtArgs>
            result: $Utils.Optional<SubjectCountAggregateOutputType> | number
          }
        }
      }
      BookSubject: {
        payload: Prisma.$BookSubjectPayload<ExtArgs>
        fields: Prisma.BookSubjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookSubjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookSubjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          findFirst: {
            args: Prisma.BookSubjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookSubjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          findMany: {
            args: Prisma.BookSubjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>[]
          }
          create: {
            args: Prisma.BookSubjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          createMany: {
            args: Prisma.BookSubjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookSubjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>[]
          }
          delete: {
            args: Prisma.BookSubjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          update: {
            args: Prisma.BookSubjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          deleteMany: {
            args: Prisma.BookSubjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookSubjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookSubjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>[]
          }
          upsert: {
            args: Prisma.BookSubjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookSubjectPayload>
          }
          aggregate: {
            args: Prisma.BookSubjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookSubject>
          }
          groupBy: {
            args: Prisma.BookSubjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookSubjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookSubjectCountArgs<ExtArgs>
            result: $Utils.Optional<BookSubjectCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      QRCode: {
        payload: Prisma.$QRCodePayload<ExtArgs>
        fields: Prisma.QRCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QRCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QRCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          findFirst: {
            args: Prisma.QRCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QRCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          findMany: {
            args: Prisma.QRCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          create: {
            args: Prisma.QRCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          createMany: {
            args: Prisma.QRCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QRCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          delete: {
            args: Prisma.QRCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          update: {
            args: Prisma.QRCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          deleteMany: {
            args: Prisma.QRCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QRCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QRCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>[]
          }
          upsert: {
            args: Prisma.QRCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QRCodePayload>
          }
          aggregate: {
            args: Prisma.QRCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQRCode>
          }
          groupBy: {
            args: Prisma.QRCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<QRCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.QRCodeCountArgs<ExtArgs>
            result: $Utils.Optional<QRCodeCountAggregateOutputType> | number
          }
        }
      }
      Redirect: {
        payload: Prisma.$RedirectPayload<ExtArgs>
        fields: Prisma.RedirectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedirectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedirectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          findFirst: {
            args: Prisma.RedirectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedirectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          findMany: {
            args: Prisma.RedirectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          create: {
            args: Prisma.RedirectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          createMany: {
            args: Prisma.RedirectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RedirectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          delete: {
            args: Prisma.RedirectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          update: {
            args: Prisma.RedirectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          deleteMany: {
            args: Prisma.RedirectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RedirectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RedirectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>[]
          }
          upsert: {
            args: Prisma.RedirectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RedirectPayload>
          }
          aggregate: {
            args: Prisma.RedirectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRedirect>
          }
          groupBy: {
            args: Prisma.RedirectGroupByArgs<ExtArgs>
            result: $Utils.Optional<RedirectGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedirectCountArgs<ExtArgs>
            result: $Utils.Optional<RedirectCountAggregateOutputType> | number
          }
        }
      }
      AcademicYear: {
        payload: Prisma.$AcademicYearPayload<ExtArgs>
        fields: Prisma.AcademicYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findFirst: {
            args: Prisma.AcademicYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          findMany: {
            args: Prisma.AcademicYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          create: {
            args: Prisma.AcademicYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          createMany: {
            args: Prisma.AcademicYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          delete: {
            args: Prisma.AcademicYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          update: {
            args: Prisma.AcademicYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          deleteMany: {
            args: Prisma.AcademicYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AcademicYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>[]
          }
          upsert: {
            args: Prisma.AcademicYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicYearPayload>
          }
          aggregate: {
            args: Prisma.AcademicYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicYear>
          }
          groupBy: {
            args: Prisma.AcademicYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicYearCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicYearCountAggregateOutputType> | number
          }
        }
      }
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BranchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BranchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      WhitelistedUrl: {
        payload: Prisma.$WhitelistedUrlPayload<ExtArgs>
        fields: Prisma.WhitelistedUrlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistedUrlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistedUrlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          findFirst: {
            args: Prisma.WhitelistedUrlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistedUrlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          findMany: {
            args: Prisma.WhitelistedUrlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>[]
          }
          create: {
            args: Prisma.WhitelistedUrlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          createMany: {
            args: Prisma.WhitelistedUrlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhitelistedUrlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>[]
          }
          delete: {
            args: Prisma.WhitelistedUrlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          update: {
            args: Prisma.WhitelistedUrlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistedUrlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistedUrlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhitelistedUrlUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>[]
          }
          upsert: {
            args: Prisma.WhitelistedUrlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhitelistedUrlPayload>
          }
          aggregate: {
            args: Prisma.WhitelistedUrlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhitelistedUrl>
          }
          groupBy: {
            args: Prisma.WhitelistedUrlGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhitelistedUrlGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhitelistedUrlCountArgs<ExtArgs>
            result: $Utils.Optional<WhitelistedUrlCountAggregateOutputType> | number
          }
        }
      }
      BlockedUrl: {
        payload: Prisma.$BlockedUrlPayload<ExtArgs>
        fields: Prisma.BlockedUrlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUrlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUrlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          findFirst: {
            args: Prisma.BlockedUrlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUrlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          findMany: {
            args: Prisma.BlockedUrlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>[]
          }
          create: {
            args: Prisma.BlockedUrlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          createMany: {
            args: Prisma.BlockedUrlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUrlCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>[]
          }
          delete: {
            args: Prisma.BlockedUrlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          update: {
            args: Prisma.BlockedUrlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUrlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUrlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockedUrlUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>[]
          }
          upsert: {
            args: Prisma.BlockedUrlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUrlPayload>
          }
          aggregate: {
            args: Prisma.BlockedUrlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUrl>
          }
          groupBy: {
            args: Prisma.BlockedUrlGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUrlGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUrlCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUrlCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userRole?: UserRoleOmit
    permission?: PermissionOmit
    book?: BookOmit
    subject?: SubjectOmit
    bookSubject?: BookSubjectOmit
    notification?: NotificationOmit
    chapter?: ChapterOmit
    qRCode?: QRCodeOmit
    redirect?: RedirectOmit
    academicYear?: AcademicYearOmit
    branch?: BranchOmit
    whitelistedUrl?: WhitelistedUrlOmit
    blockedUrl?: BlockedUrlOmit
    settings?: SettingsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdBooks: number
    updatedBooks: number
    books: number
    createdSubjects: number
    updatedSubjects: number
    subjects: number
    createdQRCodes: number
    updatedQRCodes: number
    addedQRCodes: number
    addedUsers: number
    notifications: number
    sentNotifications: number
    updatedSettings: number
    addedBlockedUrls: number
    updatedBlockedUrls: number
    addedWhiteListedUrls: number
    updatedWhiteListedUrls: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBooks?: boolean | UserCountOutputTypeCountCreatedBooksArgs
    updatedBooks?: boolean | UserCountOutputTypeCountUpdatedBooksArgs
    books?: boolean | UserCountOutputTypeCountBooksArgs
    createdSubjects?: boolean | UserCountOutputTypeCountCreatedSubjectsArgs
    updatedSubjects?: boolean | UserCountOutputTypeCountUpdatedSubjectsArgs
    subjects?: boolean | UserCountOutputTypeCountSubjectsArgs
    createdQRCodes?: boolean | UserCountOutputTypeCountCreatedQRCodesArgs
    updatedQRCodes?: boolean | UserCountOutputTypeCountUpdatedQRCodesArgs
    addedQRCodes?: boolean | UserCountOutputTypeCountAddedQRCodesArgs
    addedUsers?: boolean | UserCountOutputTypeCountAddedUsersArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentNotifications?: boolean | UserCountOutputTypeCountSentNotificationsArgs
    updatedSettings?: boolean | UserCountOutputTypeCountUpdatedSettingsArgs
    addedBlockedUrls?: boolean | UserCountOutputTypeCountAddedBlockedUrlsArgs
    updatedBlockedUrls?: boolean | UserCountOutputTypeCountUpdatedBlockedUrlsArgs
    addedWhiteListedUrls?: boolean | UserCountOutputTypeCountAddedWhiteListedUrlsArgs
    updatedWhiteListedUrls?: boolean | UserCountOutputTypeCountUpdatedWhiteListedUrlsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedBlockedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUrlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedBlockedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUrlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddedWhiteListedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistedUrlWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUpdatedWhiteListedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistedUrlWhereInput
  }


  /**
   * Count Type UserRoleCountOutputType
   */

  export type UserRoleCountOutputType = {
    users: number
    permissions: number
  }

  export type UserRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserRoleCountOutputTypeCountUsersArgs
    permissions?: boolean | UserRoleCountOutputTypeCountPermissionsArgs
  }

  // Custom InputTypes
  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleCountOutputType
     */
    select?: UserRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }


  /**
   * Count Type PermissionCountOutputType
   */

  export type PermissionCountOutputType = {
    roles: number
  }

  export type PermissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PermissionCountOutputTypeCountRolesArgs
  }

  // Custom InputTypes
  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionCountOutputType
     */
    select?: PermissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionCountOutputType without action
   */
  export type PermissionCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type BookCountOutputType
   */

  export type BookCountOutputType = {
    subjects: number
    bookSubjects: number
  }

  export type BookCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subjects?: boolean | BookCountOutputTypeCountSubjectsArgs
    bookSubjects?: boolean | BookCountOutputTypeCountBookSubjectsArgs
  }

  // Custom InputTypes
  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookCountOutputType
     */
    select?: BookCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * BookCountOutputType without action
   */
  export type BookCountOutputTypeCountBookSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookSubjectWhereInput
  }


  /**
   * Count Type SubjectCountOutputType
   */

  export type SubjectCountOutputType = {
    branch: number
    academicYear: number
    chapters: number
    books: number
    bookSubjects: number
  }

  export type SubjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | SubjectCountOutputTypeCountBranchArgs
    academicYear?: boolean | SubjectCountOutputTypeCountAcademicYearArgs
    chapters?: boolean | SubjectCountOutputTypeCountChaptersArgs
    books?: boolean | SubjectCountOutputTypeCountBooksArgs
    bookSubjects?: boolean | SubjectCountOutputTypeCountBookSubjectsArgs
  }

  // Custom InputTypes
  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubjectCountOutputType
     */
    select?: SubjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountAcademicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * SubjectCountOutputType without action
   */
  export type SubjectCountOutputTypeCountBookSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookSubjectWhereInput
  }


  /**
   * Count Type QRCodeCountOutputType
   */

  export type QRCodeCountOutputType = {
    redirects: number
  }

  export type QRCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    redirects?: boolean | QRCodeCountOutputTypeCountRedirectsArgs
  }

  // Custom InputTypes
  /**
   * QRCodeCountOutputType without action
   */
  export type QRCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCodeCountOutputType
     */
    select?: QRCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QRCodeCountOutputType without action
   */
  export type QRCodeCountOutputTypeCountRedirectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedirectWhereInput
  }


  /**
   * Count Type AcademicYearCountOutputType
   */

  export type AcademicYearCountOutputType = {
    books: number
    subjects: number
    branchs: number
  }

  export type AcademicYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | AcademicYearCountOutputTypeCountBooksArgs
    subjects?: boolean | AcademicYearCountOutputTypeCountSubjectsArgs
    branchs?: boolean | AcademicYearCountOutputTypeCountBranchsArgs
  }

  // Custom InputTypes
  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYearCountOutputType
     */
    select?: AcademicYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }

  /**
   * AcademicYearCountOutputType without action
   */
  export type AcademicYearCountOutputTypeCountBranchsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
  }


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    years: number
    users: number
    books: number
    subjects: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    years?: boolean | BranchCountOutputTypeCountYearsArgs
    users?: boolean | BranchCountOutputTypeCountUsersArgs
    books?: boolean | BranchCountOutputTypeCountBooksArgs
    subjects?: boolean | BranchCountOutputTypeCountSubjectsArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    branchId: number | null
    addedById: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    branchId: number | null
    addedById: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    activeStatus: boolean | null
    joiningDate: Date | null
    fcmToken: string | null
    branchId: number | null
    addedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    activeStatus: boolean | null
    joiningDate: Date | null
    fcmToken: string | null
    branchId: number | null
    addedById: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    roleId: number
    name: number
    email: number
    phone: number
    password: number
    activeStatus: number
    joiningDate: number
    fcmToken: number
    branchId: number
    addedById: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    roleId?: true
    branchId?: true
    addedById?: true
    createdById?: true
    updatedById?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    roleId?: true
    branchId?: true
    addedById?: true
    createdById?: true
    updatedById?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    roleId?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    activeStatus?: true
    joiningDate?: true
    fcmToken?: true
    branchId?: true
    addedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    roleId?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    activeStatus?: true
    joiningDate?: true
    fcmToken?: true
    branchId?: true
    addedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    roleId?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    activeStatus?: true
    joiningDate?: true
    fcmToken?: true
    branchId?: true
    addedById?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    roleId: number | null
    name: string
    email: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate: Date | null
    fcmToken: string | null
    branchId: number | null
    addedById: number | null
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    activeStatus?: boolean
    joiningDate?: boolean
    fcmToken?: boolean
    branchId?: boolean
    addedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    createdBooks?: boolean | User$createdBooksArgs<ExtArgs>
    updatedBooks?: boolean | User$updatedBooksArgs<ExtArgs>
    books?: boolean | User$booksArgs<ExtArgs>
    createdSubjects?: boolean | User$createdSubjectsArgs<ExtArgs>
    updatedSubjects?: boolean | User$updatedSubjectsArgs<ExtArgs>
    subjects?: boolean | User$subjectsArgs<ExtArgs>
    createdQRCodes?: boolean | User$createdQRCodesArgs<ExtArgs>
    updatedQRCodes?: boolean | User$updatedQRCodesArgs<ExtArgs>
    addedQRCodes?: boolean | User$addedQRCodesArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
    addedUsers?: boolean | User$addedUsersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    updatedSettings?: boolean | User$updatedSettingsArgs<ExtArgs>
    addedBlockedUrls?: boolean | User$addedBlockedUrlsArgs<ExtArgs>
    updatedBlockedUrls?: boolean | User$updatedBlockedUrlsArgs<ExtArgs>
    addedWhiteListedUrls?: boolean | User$addedWhiteListedUrlsArgs<ExtArgs>
    updatedWhiteListedUrls?: boolean | User$updatedWhiteListedUrlsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    activeStatus?: boolean
    joiningDate?: boolean
    fcmToken?: boolean
    branchId?: boolean
    addedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    activeStatus?: boolean
    joiningDate?: boolean
    fcmToken?: boolean
    branchId?: boolean
    addedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    roleId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    activeStatus?: boolean
    joiningDate?: boolean
    fcmToken?: boolean
    branchId?: boolean
    addedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "name" | "email" | "phone" | "password" | "activeStatus" | "joiningDate" | "fcmToken" | "branchId" | "addedById" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    createdBooks?: boolean | User$createdBooksArgs<ExtArgs>
    updatedBooks?: boolean | User$updatedBooksArgs<ExtArgs>
    books?: boolean | User$booksArgs<ExtArgs>
    createdSubjects?: boolean | User$createdSubjectsArgs<ExtArgs>
    updatedSubjects?: boolean | User$updatedSubjectsArgs<ExtArgs>
    subjects?: boolean | User$subjectsArgs<ExtArgs>
    createdQRCodes?: boolean | User$createdQRCodesArgs<ExtArgs>
    updatedQRCodes?: boolean | User$updatedQRCodesArgs<ExtArgs>
    addedQRCodes?: boolean | User$addedQRCodesArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
    addedUsers?: boolean | User$addedUsersArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentNotifications?: boolean | User$sentNotificationsArgs<ExtArgs>
    updatedSettings?: boolean | User$updatedSettingsArgs<ExtArgs>
    addedBlockedUrls?: boolean | User$addedBlockedUrlsArgs<ExtArgs>
    updatedBlockedUrls?: boolean | User$updatedBlockedUrlsArgs<ExtArgs>
    addedWhiteListedUrls?: boolean | User$addedWhiteListedUrlsArgs<ExtArgs>
    updatedWhiteListedUrls?: boolean | User$updatedWhiteListedUrlsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | User$roleArgs<ExtArgs>
    branch?: boolean | User$branchArgs<ExtArgs>
    addedBy?: boolean | User$addedByArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$UserRolePayload<ExtArgs> | null
      branch: Prisma.$BranchPayload<ExtArgs> | null
      createdBooks: Prisma.$BookPayload<ExtArgs>[]
      updatedBooks: Prisma.$BookPayload<ExtArgs>[]
      books: Prisma.$BookPayload<ExtArgs>[]
      createdSubjects: Prisma.$SubjectPayload<ExtArgs>[]
      updatedSubjects: Prisma.$SubjectPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      createdQRCodes: Prisma.$QRCodePayload<ExtArgs>[]
      updatedQRCodes: Prisma.$QRCodePayload<ExtArgs>[]
      addedQRCodes: Prisma.$QRCodePayload<ExtArgs>[]
      addedBy: Prisma.$UserPayload<ExtArgs> | null
      addedUsers: Prisma.$UserPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentNotifications: Prisma.$NotificationPayload<ExtArgs>[]
      updatedSettings: Prisma.$SettingsPayload<ExtArgs>[]
      addedBlockedUrls: Prisma.$BlockedUrlPayload<ExtArgs>[]
      updatedBlockedUrls: Prisma.$BlockedUrlPayload<ExtArgs>[]
      addedWhiteListedUrls: Prisma.$WhitelistedUrlPayload<ExtArgs>[]
      updatedWhiteListedUrls: Prisma.$WhitelistedUrlPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number | null
      name: string
      email: string | null
      phone: string
      password: string
      activeStatus: boolean
      joiningDate: Date | null
      fcmToken: string | null
      branchId: number | null
      addedById: number | null
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends User$roleArgs<ExtArgs> = {}>(args?: Subset<T, User$roleArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    branch<T extends User$branchArgs<ExtArgs> = {}>(args?: Subset<T, User$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBooks<T extends User$createdBooksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedBooks<T extends User$updatedBooksArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedBooksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    books<T extends User$booksArgs<ExtArgs> = {}>(args?: Subset<T, User$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdSubjects<T extends User$createdSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedSubjects<T extends User$updatedSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends User$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdQRCodes<T extends User$createdQRCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdQRCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedQRCodes<T extends User$updatedQRCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedQRCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addedQRCodes<T extends User$addedQRCodesArgs<ExtArgs> = {}>(args?: Subset<T, User$addedQRCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addedBy<T extends User$addedByArgs<ExtArgs> = {}>(args?: Subset<T, User$addedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addedUsers<T extends User$addedUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$addedUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentNotifications<T extends User$sentNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$sentNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedSettings<T extends User$updatedSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedSettingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addedBlockedUrls<T extends User$addedBlockedUrlsArgs<ExtArgs> = {}>(args?: Subset<T, User$addedBlockedUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedBlockedUrls<T extends User$updatedBlockedUrlsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedBlockedUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    addedWhiteListedUrls<T extends User$addedWhiteListedUrlsArgs<ExtArgs> = {}>(args?: Subset<T, User$addedWhiteListedUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updatedWhiteListedUrls<T extends User$updatedWhiteListedUrlsArgs<ExtArgs> = {}>(args?: Subset<T, User$updatedWhiteListedUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly roleId: FieldRef<"User", 'Int'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly activeStatus: FieldRef<"User", 'Boolean'>
    readonly joiningDate: FieldRef<"User", 'DateTime'>
    readonly fcmToken: FieldRef<"User", 'String'>
    readonly branchId: FieldRef<"User", 'Int'>
    readonly addedById: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly createdById: FieldRef<"User", 'Int'>
    readonly updatedById: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.role
   */
  export type User$roleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
  }

  /**
   * User.branch
   */
  export type User$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * User.createdBooks
   */
  export type User$createdBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * User.updatedBooks
   */
  export type User$updatedBooksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * User.books
   */
  export type User$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * User.createdSubjects
   */
  export type User$createdSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * User.updatedSubjects
   */
  export type User$updatedSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * User.subjects
   */
  export type User$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * User.createdQRCodes
   */
  export type User$createdQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    cursor?: QRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * User.updatedQRCodes
   */
  export type User$updatedQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    cursor?: QRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * User.addedQRCodes
   */
  export type User$addedQRCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    cursor?: QRCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * User.addedBy
   */
  export type User$addedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * User.addedUsers
   */
  export type User$addedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentNotifications
   */
  export type User$sentNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.updatedSettings
   */
  export type User$updatedSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    cursor?: SettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * User.addedBlockedUrls
   */
  export type User$addedBlockedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    where?: BlockedUrlWhereInput
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    cursor?: BlockedUrlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUrlScalarFieldEnum | BlockedUrlScalarFieldEnum[]
  }

  /**
   * User.updatedBlockedUrls
   */
  export type User$updatedBlockedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    where?: BlockedUrlWhereInput
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    cursor?: BlockedUrlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUrlScalarFieldEnum | BlockedUrlScalarFieldEnum[]
  }

  /**
   * User.addedWhiteListedUrls
   */
  export type User$addedWhiteListedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    where?: WhitelistedUrlWhereInput
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    cursor?: WhitelistedUrlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistedUrlScalarFieldEnum | WhitelistedUrlScalarFieldEnum[]
  }

  /**
   * User.updatedWhiteListedUrls
   */
  export type User$updatedWhiteListedUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    where?: WhitelistedUrlWhereInput
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    cursor?: WhitelistedUrlWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhitelistedUrlScalarFieldEnum | WhitelistedUrlScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    roleId: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    roleId: number | null
    role: string | null
    name: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    roleId: number | null
    role: string | null
    name: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    roleId: number
    role: number
    name: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    roleId?: true
  }

  export type UserRoleSumAggregateInputType = {
    roleId?: true
  }

  export type UserRoleMinAggregateInputType = {
    roleId?: true
    role?: true
    name?: true
  }

  export type UserRoleMaxAggregateInputType = {
    roleId?: true
    role?: true
    name?: true
  }

  export type UserRoleCountAggregateInputType = {
    roleId?: true
    role?: true
    name?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    roleId: number
    role: string
    name: string
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    role?: boolean
    name?: boolean
    users?: boolean | UserRole$usersArgs<ExtArgs>
    permissions?: boolean | UserRole$permissionsArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    role?: boolean
    name?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    roleId?: boolean
    role?: boolean
    name?: boolean
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    roleId?: boolean
    role?: boolean
    name?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"roleId" | "role" | "name", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | UserRole$usersArgs<ExtArgs>
    permissions?: boolean | UserRole$permissionsArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      roleId: number
      role: string
      name: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `roleId`
     * const userRoleWithRoleIdOnly = await prisma.userRole.findMany({ select: { roleId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `roleId`
     * const userRoleWithRoleIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { roleId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `roleId`
     * const userRoleWithRoleIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { roleId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends UserRole$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissions<T extends UserRole$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly roleId: FieldRef<"UserRole", 'Int'>
    readonly role: FieldRef<"UserRole", 'String'>
    readonly name: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole.users
   */
  export type UserRole$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserRole.permissions
   */
  export type UserRole$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    permissionId: number | null
  }

  export type PermissionSumAggregateOutputType = {
    permissionId: number | null
  }

  export type PermissionMinAggregateOutputType = {
    permissionId: number | null
    name: string | null
    permissionCode: string | null
    description: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    permissionId: number | null
    name: string | null
    permissionCode: string | null
    description: string | null
  }

  export type PermissionCountAggregateOutputType = {
    permissionId: number
    name: number
    permissionCode: number
    description: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    permissionId?: true
  }

  export type PermissionSumAggregateInputType = {
    permissionId?: true
  }

  export type PermissionMinAggregateInputType = {
    permissionId?: true
    name?: true
    permissionCode?: true
    description?: true
  }

  export type PermissionMaxAggregateInputType = {
    permissionId?: true
    name?: true
    permissionCode?: true
    description?: true
  }

  export type PermissionCountAggregateInputType = {
    permissionId?: true
    name?: true
    permissionCode?: true
    description?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    permissionId: number
    name: string
    permissionCode: string
    description: string | null
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissionId?: boolean
    name?: boolean
    permissionCode?: boolean
    description?: boolean
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissionId?: boolean
    name?: boolean
    permissionCode?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permissionId?: boolean
    name?: boolean
    permissionCode?: boolean
    description?: boolean
  }, ExtArgs["result"]["permission"]>

  export type PermissionSelectScalar = {
    permissionId?: boolean
    name?: boolean
    permissionCode?: boolean
    description?: boolean
  }

  export type PermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permissionId" | "name" | "permissionCode" | "description", ExtArgs["result"]["permission"]>
  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Permission$rolesArgs<ExtArgs>
    _count?: boolean | PermissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      permissionId: number
      name: string
      permissionCode: string
      description: string | null
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `permissionId`
     * const permissionWithPermissionIdOnly = await prisma.permission.findMany({ select: { permissionId: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permissions and returns the data saved in the database.
     * @param {PermissionCreateManyAndReturnArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permissions and only return the `permissionId`
     * const permissionWithPermissionIdOnly = await prisma.permission.createManyAndReturn({
     *   select: { permissionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions and returns the data updated in the database.
     * @param {PermissionUpdateManyAndReturnArgs} args - Arguments to update many Permissions.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permissions and only return the `permissionId`
     * const permissionWithPermissionIdOnly = await prisma.permission.updateManyAndReturn({
     *   select: { permissionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Permission$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Permission$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */
  interface PermissionFieldRefs {
    readonly permissionId: FieldRef<"Permission", 'Int'>
    readonly name: FieldRef<"Permission", 'String'>
    readonly permissionCode: FieldRef<"Permission", 'String'>
    readonly description: FieldRef<"Permission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission createManyAndReturn
   */
  export type PermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission updateManyAndReturn
   */
  export type PermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to update.
     */
    limit?: number
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
    /**
     * Limit how many Permissions to delete.
     */
    limit?: number
  }

  /**
   * Permission.roles
   */
  export type Permission$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permission
     */
    omit?: PermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Book
   */

  export type AggregateBook = {
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  export type BookAvgAggregateOutputType = {
    userId: number | null
    branchId: number | null
    academicYearId: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type BookSumAggregateOutputType = {
    userId: number | null
    branchId: number | null
    academicYearId: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type BookMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    publisher: string | null
    userId: number | null
    branchId: number | null
    academicYearId: number | null
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    publisher: string | null
    userId: number | null
    branchId: number | null
    academicYearId: number | null
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookCountAggregateOutputType = {
    id: number
    title: number
    description: number
    publisher: number
    userId: number
    branchId: number
    academicYearId: number
    createdById: number
    updatedById: number
    deletedAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookAvgAggregateInputType = {
    userId?: true
    branchId?: true
    academicYearId?: true
    createdById?: true
    updatedById?: true
  }

  export type BookSumAggregateInputType = {
    userId?: true
    branchId?: true
    academicYearId?: true
    createdById?: true
    updatedById?: true
  }

  export type BookMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    publisher?: true
    userId?: true
    branchId?: true
    academicYearId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    publisher?: true
    userId?: true
    branchId?: true
    academicYearId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    publisher?: true
    userId?: true
    branchId?: true
    academicYearId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Book to aggregate.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Books
    **/
    _count?: true | BookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookMaxAggregateInputType
  }

  export type GetBookAggregateType<T extends BookAggregateArgs> = {
        [P in keyof T & keyof AggregateBook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBook[P]>
      : GetScalarType<T[P], AggregateBook[P]>
  }




  export type BookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookWhereInput
    orderBy?: BookOrderByWithAggregationInput | BookOrderByWithAggregationInput[]
    by: BookScalarFieldEnum[] | BookScalarFieldEnum
    having?: BookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookCountAggregateInputType | true
    _avg?: BookAvgAggregateInputType
    _sum?: BookSumAggregateInputType
    _min?: BookMinAggregateInputType
    _max?: BookMaxAggregateInputType
  }

  export type BookGroupByOutputType = {
    id: string
    title: string
    description: string | null
    publisher: string | null
    userId: number
    branchId: number | null
    academicYearId: number | null
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookCountAggregateOutputType | null
    _avg: BookAvgAggregateOutputType | null
    _sum: BookSumAggregateOutputType | null
    _min: BookMinAggregateOutputType | null
    _max: BookMaxAggregateOutputType | null
  }

  type GetBookGroupByPayload<T extends BookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookGroupByOutputType[P]>
            : GetScalarType<T[P], BookGroupByOutputType[P]>
        }
      >
    >


  export type BookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    publisher?: boolean
    userId?: boolean
    branchId?: boolean
    academicYearId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
    subjects?: boolean | Book$subjectsArgs<ExtArgs>
    bookSubjects?: boolean | Book$bookSubjectsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    publisher?: boolean
    userId?: boolean
    branchId?: boolean
    academicYearId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    publisher?: boolean
    userId?: boolean
    branchId?: boolean
    academicYearId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["book"]>

  export type BookSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    publisher?: boolean
    userId?: boolean
    branchId?: boolean
    academicYearId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "publisher" | "userId" | "branchId" | "academicYearId" | "createdById" | "updatedById" | "deletedAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["book"]>
  export type BookInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
    subjects?: boolean | Book$subjectsArgs<ExtArgs>
    bookSubjects?: boolean | Book$bookSubjectsArgs<ExtArgs>
    _count?: boolean | BookCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
  }
  export type BookIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Book$branchArgs<ExtArgs>
    academicYear?: boolean | Book$academicYearArgs<ExtArgs>
    createdBy?: boolean | Book$createdByArgs<ExtArgs>
    updatedBy?: boolean | Book$updatedByArgs<ExtArgs>
  }

  export type $BookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Book"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs> | null
      academicYear: Prisma.$AcademicYearPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      bookSubjects: Prisma.$BookSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      publisher: string | null
      userId: number
      branchId: number | null
      academicYearId: number | null
      createdById: number | null
      updatedById: number | null
      deletedAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["book"]>
    composites: {}
  }

  type BookGetPayload<S extends boolean | null | undefined | BookDefaultArgs> = $Result.GetResult<Prisma.$BookPayload, S>

  type BookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookCountAggregateInputType | true
    }

  export interface BookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Book'], meta: { name: 'Book' } }
    /**
     * Find zero or one Book that matches the filter.
     * @param {BookFindUniqueArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookFindUniqueArgs>(args: SelectSubset<T, BookFindUniqueArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Book that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookFindUniqueOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookFindUniqueOrThrowArgs>(args: SelectSubset<T, BookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookFindFirstArgs>(args?: SelectSubset<T, BookFindFirstArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Book that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindFirstOrThrowArgs} args - Arguments to find a Book
     * @example
     * // Get one Book
     * const book = await prisma.book.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookFindFirstOrThrowArgs>(args?: SelectSubset<T, BookFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Books that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Books
     * const books = await prisma.book.findMany()
     * 
     * // Get first 10 Books
     * const books = await prisma.book.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookWithIdOnly = await prisma.book.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookFindManyArgs>(args?: SelectSubset<T, BookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Book.
     * @param {BookCreateArgs} args - Arguments to create a Book.
     * @example
     * // Create one Book
     * const Book = await prisma.book.create({
     *   data: {
     *     // ... data to create a Book
     *   }
     * })
     * 
     */
    create<T extends BookCreateArgs>(args: SelectSubset<T, BookCreateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Books.
     * @param {BookCreateManyArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookCreateManyArgs>(args?: SelectSubset<T, BookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Books and returns the data saved in the database.
     * @param {BookCreateManyAndReturnArgs} args - Arguments to create many Books.
     * @example
     * // Create many Books
     * const book = await prisma.book.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookCreateManyAndReturnArgs>(args?: SelectSubset<T, BookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Book.
     * @param {BookDeleteArgs} args - Arguments to delete one Book.
     * @example
     * // Delete one Book
     * const Book = await prisma.book.delete({
     *   where: {
     *     // ... filter to delete one Book
     *   }
     * })
     * 
     */
    delete<T extends BookDeleteArgs>(args: SelectSubset<T, BookDeleteArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Book.
     * @param {BookUpdateArgs} args - Arguments to update one Book.
     * @example
     * // Update one Book
     * const book = await prisma.book.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookUpdateArgs>(args: SelectSubset<T, BookUpdateArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Books.
     * @param {BookDeleteManyArgs} args - Arguments to filter Books to delete.
     * @example
     * // Delete a few Books
     * const { count } = await prisma.book.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookDeleteManyArgs>(args?: SelectSubset<T, BookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookUpdateManyArgs>(args: SelectSubset<T, BookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Books and returns the data updated in the database.
     * @param {BookUpdateManyAndReturnArgs} args - Arguments to update many Books.
     * @example
     * // Update many Books
     * const book = await prisma.book.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Books and only return the `id`
     * const bookWithIdOnly = await prisma.book.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookUpdateManyAndReturnArgs>(args: SelectSubset<T, BookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Book.
     * @param {BookUpsertArgs} args - Arguments to update or create a Book.
     * @example
     * // Update or create a Book
     * const book = await prisma.book.upsert({
     *   create: {
     *     // ... data to create a Book
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Book we want to update
     *   }
     * })
     */
    upsert<T extends BookUpsertArgs>(args: SelectSubset<T, BookUpsertArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Books.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookCountArgs} args - Arguments to filter Books to count.
     * @example
     * // Count the number of Books
     * const count = await prisma.book.count({
     *   where: {
     *     // ... the filter for the Books we want to count
     *   }
     * })
    **/
    count<T extends BookCountArgs>(
      args?: Subset<T, BookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookAggregateArgs>(args: Subset<T, BookAggregateArgs>): Prisma.PrismaPromise<GetBookAggregateType<T>>

    /**
     * Group by Book.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookGroupByArgs['orderBy'] }
        : { orderBy?: BookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Book model
   */
  readonly fields: BookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Book.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends Book$branchArgs<ExtArgs> = {}>(args?: Subset<T, Book$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    academicYear<T extends Book$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, Book$academicYearArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Book$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Book$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Book$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Book$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subjects<T extends Book$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Book$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookSubjects<T extends Book$bookSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Book$bookSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Book model
   */
  interface BookFieldRefs {
    readonly id: FieldRef<"Book", 'String'>
    readonly title: FieldRef<"Book", 'String'>
    readonly description: FieldRef<"Book", 'String'>
    readonly publisher: FieldRef<"Book", 'String'>
    readonly userId: FieldRef<"Book", 'Int'>
    readonly branchId: FieldRef<"Book", 'Int'>
    readonly academicYearId: FieldRef<"Book", 'Int'>
    readonly createdById: FieldRef<"Book", 'Int'>
    readonly updatedById: FieldRef<"Book", 'Int'>
    readonly deletedAt: FieldRef<"Book", 'DateTime'>
    readonly isDeleted: FieldRef<"Book", 'Boolean'>
    readonly createdAt: FieldRef<"Book", 'DateTime'>
    readonly updatedAt: FieldRef<"Book", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Book findUnique
   */
  export type BookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findUniqueOrThrow
   */
  export type BookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book findFirst
   */
  export type BookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findFirstOrThrow
   */
  export type BookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Book to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Books.
     */
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book findMany
   */
  export type BookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter, which Books to fetch.
     */
    where?: BookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Books to fetch.
     */
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Books.
     */
    cursor?: BookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Books from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Books.
     */
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Book create
   */
  export type BookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to create a Book.
     */
    data: XOR<BookCreateInput, BookUncheckedCreateInput>
  }

  /**
   * Book createMany
   */
  export type BookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Book createManyAndReturn
   */
  export type BookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to create many Books.
     */
    data: BookCreateManyInput | BookCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book update
   */
  export type BookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The data needed to update a Book.
     */
    data: XOR<BookUpdateInput, BookUncheckedUpdateInput>
    /**
     * Choose, which Book to update.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book updateMany
   */
  export type BookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
  }

  /**
   * Book updateManyAndReturn
   */
  export type BookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * The data used to update Books.
     */
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyInput>
    /**
     * Filter which Books to update
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Book upsert
   */
  export type BookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * The filter to search for the Book to update in case it exists.
     */
    where: BookWhereUniqueInput
    /**
     * In case the Book found by the `where` argument doesn't exist, create a new Book with this data.
     */
    create: XOR<BookCreateInput, BookUncheckedCreateInput>
    /**
     * In case the Book was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookUpdateInput, BookUncheckedUpdateInput>
  }

  /**
   * Book delete
   */
  export type BookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    /**
     * Filter which Book to delete.
     */
    where: BookWhereUniqueInput
  }

  /**
   * Book deleteMany
   */
  export type BookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Books to delete
     */
    where?: BookWhereInput
    /**
     * Limit how many Books to delete.
     */
    limit?: number
  }

  /**
   * Book.branch
   */
  export type Book$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Book.academicYear
   */
  export type Book$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
  }

  /**
   * Book.createdBy
   */
  export type Book$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Book.updatedBy
   */
  export type Book$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Book.subjects
   */
  export type Book$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Book.bookSubjects
   */
  export type Book$bookSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    where?: BookSubjectWhereInput
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    cursor?: BookSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookSubjectScalarFieldEnum | BookSubjectScalarFieldEnum[]
  }

  /**
   * Book without action
   */
  export type BookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
  }


  /**
   * Model Subject
   */

  export type AggregateSubject = {
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  export type SubjectAvgAggregateOutputType = {
    userId: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type SubjectSumAggregateOutputType = {
    userId: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type SubjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: number | null
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    userId: number | null
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    userId: number
    createdById: number
    updatedById: number
    deletedAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubjectAvgAggregateInputType = {
    userId?: true
    createdById?: true
    updatedById?: true
  }

  export type SubjectSumAggregateInputType = {
    userId?: true
    createdById?: true
    updatedById?: true
  }

  export type SubjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    userId?: true
    createdById?: true
    updatedById?: true
    deletedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subject to aggregate.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subjects
    **/
    _count?: true | SubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubjectMaxAggregateInputType
  }

  export type GetSubjectAggregateType<T extends SubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubject[P]>
      : GetScalarType<T[P], AggregateSubject[P]>
  }




  export type SubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithAggregationInput | SubjectOrderByWithAggregationInput[]
    by: SubjectScalarFieldEnum[] | SubjectScalarFieldEnum
    having?: SubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubjectCountAggregateInputType | true
    _avg?: SubjectAvgAggregateInputType
    _sum?: SubjectSumAggregateInputType
    _min?: SubjectMinAggregateInputType
    _max?: SubjectMaxAggregateInputType
  }

  export type SubjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    userId: number
    createdById: number | null
    updatedById: number | null
    deletedAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: SubjectCountAggregateOutputType | null
    _avg: SubjectAvgAggregateOutputType | null
    _sum: SubjectSumAggregateOutputType | null
    _min: SubjectMinAggregateOutputType | null
    _max: SubjectMaxAggregateOutputType | null
  }

  type GetSubjectGroupByPayload<T extends SubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubjectGroupByOutputType[P]>
            : GetScalarType<T[P], SubjectGroupByOutputType[P]>
        }
      >
    >


  export type SubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Subject$branchArgs<ExtArgs>
    academicYear?: boolean | Subject$academicYearArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    books?: boolean | Subject$booksArgs<ExtArgs>
    bookSubjects?: boolean | Subject$bookSubjectsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["subject"]>

  export type SubjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    userId?: boolean
    createdById?: boolean
    updatedById?: boolean
    deletedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "userId" | "createdById" | "updatedById" | "deletedAt" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["subject"]>
  export type SubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    branch?: boolean | Subject$branchArgs<ExtArgs>
    academicYear?: boolean | Subject$academicYearArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
    chapters?: boolean | Subject$chaptersArgs<ExtArgs>
    books?: boolean | Subject$booksArgs<ExtArgs>
    bookSubjects?: boolean | Subject$bookSubjectsArgs<ExtArgs>
    _count?: boolean | SubjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
  }
  export type SubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | Subject$createdByArgs<ExtArgs>
    updatedBy?: boolean | Subject$updatedByArgs<ExtArgs>
  }

  export type $SubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subject"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      branch: Prisma.$BranchPayload<ExtArgs>[]
      academicYear: Prisma.$AcademicYearPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      books: Prisma.$BookPayload<ExtArgs>[]
      bookSubjects: Prisma.$BookSubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      userId: number
      createdById: number | null
      updatedById: number | null
      deletedAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subject"]>
    composites: {}
  }

  type SubjectGetPayload<S extends boolean | null | undefined | SubjectDefaultArgs> = $Result.GetResult<Prisma.$SubjectPayload, S>

  type SubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubjectCountAggregateInputType | true
    }

  export interface SubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subject'], meta: { name: 'Subject' } }
    /**
     * Find zero or one Subject that matches the filter.
     * @param {SubjectFindUniqueArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubjectFindUniqueArgs>(args: SelectSubset<T, SubjectFindUniqueArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubjectFindUniqueOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, SubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubjectFindFirstArgs>(args?: SelectSubset<T, SubjectFindFirstArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindFirstOrThrowArgs} args - Arguments to find a Subject
     * @example
     * // Get one Subject
     * const subject = await prisma.subject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, SubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subjects
     * const subjects = await prisma.subject.findMany()
     * 
     * // Get first 10 Subjects
     * const subjects = await prisma.subject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subjectWithIdOnly = await prisma.subject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubjectFindManyArgs>(args?: SelectSubset<T, SubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subject.
     * @param {SubjectCreateArgs} args - Arguments to create a Subject.
     * @example
     * // Create one Subject
     * const Subject = await prisma.subject.create({
     *   data: {
     *     // ... data to create a Subject
     *   }
     * })
     * 
     */
    create<T extends SubjectCreateArgs>(args: SelectSubset<T, SubjectCreateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subjects.
     * @param {SubjectCreateManyArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubjectCreateManyArgs>(args?: SelectSubset<T, SubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subjects and returns the data saved in the database.
     * @param {SubjectCreateManyAndReturnArgs} args - Arguments to create many Subjects.
     * @example
     * // Create many Subjects
     * const subject = await prisma.subject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, SubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subject.
     * @param {SubjectDeleteArgs} args - Arguments to delete one Subject.
     * @example
     * // Delete one Subject
     * const Subject = await prisma.subject.delete({
     *   where: {
     *     // ... filter to delete one Subject
     *   }
     * })
     * 
     */
    delete<T extends SubjectDeleteArgs>(args: SelectSubset<T, SubjectDeleteArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subject.
     * @param {SubjectUpdateArgs} args - Arguments to update one Subject.
     * @example
     * // Update one Subject
     * const subject = await prisma.subject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubjectUpdateArgs>(args: SelectSubset<T, SubjectUpdateArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subjects.
     * @param {SubjectDeleteManyArgs} args - Arguments to filter Subjects to delete.
     * @example
     * // Delete a few Subjects
     * const { count } = await prisma.subject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubjectDeleteManyArgs>(args?: SelectSubset<T, SubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubjectUpdateManyArgs>(args: SelectSubset<T, SubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subjects and returns the data updated in the database.
     * @param {SubjectUpdateManyAndReturnArgs} args - Arguments to update many Subjects.
     * @example
     * // Update many Subjects
     * const subject = await prisma.subject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subjects and only return the `id`
     * const subjectWithIdOnly = await prisma.subject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, SubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subject.
     * @param {SubjectUpsertArgs} args - Arguments to update or create a Subject.
     * @example
     * // Update or create a Subject
     * const subject = await prisma.subject.upsert({
     *   create: {
     *     // ... data to create a Subject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subject we want to update
     *   }
     * })
     */
    upsert<T extends SubjectUpsertArgs>(args: SelectSubset<T, SubjectUpsertArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectCountArgs} args - Arguments to filter Subjects to count.
     * @example
     * // Count the number of Subjects
     * const count = await prisma.subject.count({
     *   where: {
     *     // ... the filter for the Subjects we want to count
     *   }
     * })
    **/
    count<T extends SubjectCountArgs>(
      args?: Subset<T, SubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubjectAggregateArgs>(args: Subset<T, SubjectAggregateArgs>): Prisma.PrismaPromise<GetSubjectAggregateType<T>>

    /**
     * Group by Subject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubjectGroupByArgs['orderBy'] }
        : { orderBy?: SubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subject model
   */
  readonly fields: SubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    branch<T extends Subject$branchArgs<ExtArgs> = {}>(args?: Subset<T, Subject$branchArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    academicYear<T extends Subject$academicYearArgs<ExtArgs> = {}>(args?: Subset<T, Subject$academicYearArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends Subject$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Subject$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends Subject$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Subject$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chapters<T extends Subject$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Subject$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    books<T extends Subject$booksArgs<ExtArgs> = {}>(args?: Subset<T, Subject$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookSubjects<T extends Subject$bookSubjectsArgs<ExtArgs> = {}>(args?: Subset<T, Subject$bookSubjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subject model
   */
  interface SubjectFieldRefs {
    readonly id: FieldRef<"Subject", 'String'>
    readonly name: FieldRef<"Subject", 'String'>
    readonly description: FieldRef<"Subject", 'String'>
    readonly userId: FieldRef<"Subject", 'Int'>
    readonly createdById: FieldRef<"Subject", 'Int'>
    readonly updatedById: FieldRef<"Subject", 'Int'>
    readonly deletedAt: FieldRef<"Subject", 'DateTime'>
    readonly isDeleted: FieldRef<"Subject", 'Boolean'>
    readonly createdAt: FieldRef<"Subject", 'DateTime'>
    readonly updatedAt: FieldRef<"Subject", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subject findUnique
   */
  export type SubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findUniqueOrThrow
   */
  export type SubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject findFirst
   */
  export type SubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findFirstOrThrow
   */
  export type SubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subject to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subjects.
     */
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject findMany
   */
  export type SubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter, which Subjects to fetch.
     */
    where?: SubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subjects to fetch.
     */
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subjects.
     */
    cursor?: SubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subjects.
     */
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Subject create
   */
  export type SubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Subject.
     */
    data: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
  }

  /**
   * Subject createMany
   */
  export type SubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subject createManyAndReturn
   */
  export type SubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to create many Subjects.
     */
    data: SubjectCreateManyInput | SubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject update
   */
  export type SubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Subject.
     */
    data: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
    /**
     * Choose, which Subject to update.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject updateMany
   */
  export type SubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
  }

  /**
   * Subject updateManyAndReturn
   */
  export type SubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * The data used to update Subjects.
     */
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyInput>
    /**
     * Filter which Subjects to update
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subject upsert
   */
  export type SubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Subject to update in case it exists.
     */
    where: SubjectWhereUniqueInput
    /**
     * In case the Subject found by the `where` argument doesn't exist, create a new Subject with this data.
     */
    create: XOR<SubjectCreateInput, SubjectUncheckedCreateInput>
    /**
     * In case the Subject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubjectUpdateInput, SubjectUncheckedUpdateInput>
  }

  /**
   * Subject delete
   */
  export type SubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    /**
     * Filter which Subject to delete.
     */
    where: SubjectWhereUniqueInput
  }

  /**
   * Subject deleteMany
   */
  export type SubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subjects to delete
     */
    where?: SubjectWhereInput
    /**
     * Limit how many Subjects to delete.
     */
    limit?: number
  }

  /**
   * Subject.branch
   */
  export type Subject$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Subject.academicYear
   */
  export type Subject$academicYearArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    cursor?: AcademicYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * Subject.createdBy
   */
  export type Subject$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subject.updatedBy
   */
  export type Subject$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Subject.chapters
   */
  export type Subject$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Subject.books
   */
  export type Subject$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Subject.bookSubjects
   */
  export type Subject$bookSubjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    where?: BookSubjectWhereInput
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    cursor?: BookSubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookSubjectScalarFieldEnum | BookSubjectScalarFieldEnum[]
  }

  /**
   * Subject without action
   */
  export type SubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
  }


  /**
   * Model BookSubject
   */

  export type AggregateBookSubject = {
    _count: BookSubjectCountAggregateOutputType | null
    _avg: BookSubjectAvgAggregateOutputType | null
    _sum: BookSubjectSumAggregateOutputType | null
    _min: BookSubjectMinAggregateOutputType | null
    _max: BookSubjectMaxAggregateOutputType | null
  }

  export type BookSubjectAvgAggregateOutputType = {
    id: number | null
  }

  export type BookSubjectSumAggregateOutputType = {
    id: number | null
  }

  export type BookSubjectMinAggregateOutputType = {
    id: number | null
    bookId: string | null
    subjectId: string | null
  }

  export type BookSubjectMaxAggregateOutputType = {
    id: number | null
    bookId: string | null
    subjectId: string | null
  }

  export type BookSubjectCountAggregateOutputType = {
    id: number
    bookId: number
    subjectId: number
    _all: number
  }


  export type BookSubjectAvgAggregateInputType = {
    id?: true
  }

  export type BookSubjectSumAggregateInputType = {
    id?: true
  }

  export type BookSubjectMinAggregateInputType = {
    id?: true
    bookId?: true
    subjectId?: true
  }

  export type BookSubjectMaxAggregateInputType = {
    id?: true
    bookId?: true
    subjectId?: true
  }

  export type BookSubjectCountAggregateInputType = {
    id?: true
    bookId?: true
    subjectId?: true
    _all?: true
  }

  export type BookSubjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookSubject to aggregate.
     */
    where?: BookSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSubjects to fetch.
     */
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookSubjects
    **/
    _count?: true | BookSubjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookSubjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookSubjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookSubjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookSubjectMaxAggregateInputType
  }

  export type GetBookSubjectAggregateType<T extends BookSubjectAggregateArgs> = {
        [P in keyof T & keyof AggregateBookSubject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookSubject[P]>
      : GetScalarType<T[P], AggregateBookSubject[P]>
  }




  export type BookSubjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookSubjectWhereInput
    orderBy?: BookSubjectOrderByWithAggregationInput | BookSubjectOrderByWithAggregationInput[]
    by: BookSubjectScalarFieldEnum[] | BookSubjectScalarFieldEnum
    having?: BookSubjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookSubjectCountAggregateInputType | true
    _avg?: BookSubjectAvgAggregateInputType
    _sum?: BookSubjectSumAggregateInputType
    _min?: BookSubjectMinAggregateInputType
    _max?: BookSubjectMaxAggregateInputType
  }

  export type BookSubjectGroupByOutputType = {
    id: number
    bookId: string
    subjectId: string
    _count: BookSubjectCountAggregateOutputType | null
    _avg: BookSubjectAvgAggregateOutputType | null
    _sum: BookSubjectSumAggregateOutputType | null
    _min: BookSubjectMinAggregateOutputType | null
    _max: BookSubjectMaxAggregateOutputType | null
  }

  type GetBookSubjectGroupByPayload<T extends BookSubjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookSubjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookSubjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookSubjectGroupByOutputType[P]>
            : GetScalarType<T[P], BookSubjectGroupByOutputType[P]>
        }
      >
    >


  export type BookSubjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    subjectId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSubject"]>

  export type BookSubjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    subjectId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSubject"]>

  export type BookSubjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookId?: boolean
    subjectId?: boolean
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookSubject"]>

  export type BookSubjectSelectScalar = {
    id?: boolean
    bookId?: boolean
    subjectId?: boolean
  }

  export type BookSubjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookId" | "subjectId", ExtArgs["result"]["bookSubject"]>
  export type BookSubjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type BookSubjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type BookSubjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    book?: boolean | BookDefaultArgs<ExtArgs>
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $BookSubjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookSubject"
    objects: {
      book: Prisma.$BookPayload<ExtArgs>
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookId: string
      subjectId: string
    }, ExtArgs["result"]["bookSubject"]>
    composites: {}
  }

  type BookSubjectGetPayload<S extends boolean | null | undefined | BookSubjectDefaultArgs> = $Result.GetResult<Prisma.$BookSubjectPayload, S>

  type BookSubjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookSubjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookSubjectCountAggregateInputType | true
    }

  export interface BookSubjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookSubject'], meta: { name: 'BookSubject' } }
    /**
     * Find zero or one BookSubject that matches the filter.
     * @param {BookSubjectFindUniqueArgs} args - Arguments to find a BookSubject
     * @example
     * // Get one BookSubject
     * const bookSubject = await prisma.bookSubject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookSubjectFindUniqueArgs>(args: SelectSubset<T, BookSubjectFindUniqueArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookSubject that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookSubjectFindUniqueOrThrowArgs} args - Arguments to find a BookSubject
     * @example
     * // Get one BookSubject
     * const bookSubject = await prisma.bookSubject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookSubjectFindUniqueOrThrowArgs>(args: SelectSubset<T, BookSubjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookSubject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectFindFirstArgs} args - Arguments to find a BookSubject
     * @example
     * // Get one BookSubject
     * const bookSubject = await prisma.bookSubject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookSubjectFindFirstArgs>(args?: SelectSubset<T, BookSubjectFindFirstArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookSubject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectFindFirstOrThrowArgs} args - Arguments to find a BookSubject
     * @example
     * // Get one BookSubject
     * const bookSubject = await prisma.bookSubject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookSubjectFindFirstOrThrowArgs>(args?: SelectSubset<T, BookSubjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookSubjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookSubjects
     * const bookSubjects = await prisma.bookSubject.findMany()
     * 
     * // Get first 10 BookSubjects
     * const bookSubjects = await prisma.bookSubject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookSubjectWithIdOnly = await prisma.bookSubject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookSubjectFindManyArgs>(args?: SelectSubset<T, BookSubjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookSubject.
     * @param {BookSubjectCreateArgs} args - Arguments to create a BookSubject.
     * @example
     * // Create one BookSubject
     * const BookSubject = await prisma.bookSubject.create({
     *   data: {
     *     // ... data to create a BookSubject
     *   }
     * })
     * 
     */
    create<T extends BookSubjectCreateArgs>(args: SelectSubset<T, BookSubjectCreateArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookSubjects.
     * @param {BookSubjectCreateManyArgs} args - Arguments to create many BookSubjects.
     * @example
     * // Create many BookSubjects
     * const bookSubject = await prisma.bookSubject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookSubjectCreateManyArgs>(args?: SelectSubset<T, BookSubjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookSubjects and returns the data saved in the database.
     * @param {BookSubjectCreateManyAndReturnArgs} args - Arguments to create many BookSubjects.
     * @example
     * // Create many BookSubjects
     * const bookSubject = await prisma.bookSubject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookSubjects and only return the `id`
     * const bookSubjectWithIdOnly = await prisma.bookSubject.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookSubjectCreateManyAndReturnArgs>(args?: SelectSubset<T, BookSubjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookSubject.
     * @param {BookSubjectDeleteArgs} args - Arguments to delete one BookSubject.
     * @example
     * // Delete one BookSubject
     * const BookSubject = await prisma.bookSubject.delete({
     *   where: {
     *     // ... filter to delete one BookSubject
     *   }
     * })
     * 
     */
    delete<T extends BookSubjectDeleteArgs>(args: SelectSubset<T, BookSubjectDeleteArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookSubject.
     * @param {BookSubjectUpdateArgs} args - Arguments to update one BookSubject.
     * @example
     * // Update one BookSubject
     * const bookSubject = await prisma.bookSubject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookSubjectUpdateArgs>(args: SelectSubset<T, BookSubjectUpdateArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookSubjects.
     * @param {BookSubjectDeleteManyArgs} args - Arguments to filter BookSubjects to delete.
     * @example
     * // Delete a few BookSubjects
     * const { count } = await prisma.bookSubject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookSubjectDeleteManyArgs>(args?: SelectSubset<T, BookSubjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookSubjects
     * const bookSubject = await prisma.bookSubject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookSubjectUpdateManyArgs>(args: SelectSubset<T, BookSubjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookSubjects and returns the data updated in the database.
     * @param {BookSubjectUpdateManyAndReturnArgs} args - Arguments to update many BookSubjects.
     * @example
     * // Update many BookSubjects
     * const bookSubject = await prisma.bookSubject.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookSubjects and only return the `id`
     * const bookSubjectWithIdOnly = await prisma.bookSubject.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookSubjectUpdateManyAndReturnArgs>(args: SelectSubset<T, BookSubjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookSubject.
     * @param {BookSubjectUpsertArgs} args - Arguments to update or create a BookSubject.
     * @example
     * // Update or create a BookSubject
     * const bookSubject = await prisma.bookSubject.upsert({
     *   create: {
     *     // ... data to create a BookSubject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookSubject we want to update
     *   }
     * })
     */
    upsert<T extends BookSubjectUpsertArgs>(args: SelectSubset<T, BookSubjectUpsertArgs<ExtArgs>>): Prisma__BookSubjectClient<$Result.GetResult<Prisma.$BookSubjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookSubjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectCountArgs} args - Arguments to filter BookSubjects to count.
     * @example
     * // Count the number of BookSubjects
     * const count = await prisma.bookSubject.count({
     *   where: {
     *     // ... the filter for the BookSubjects we want to count
     *   }
     * })
    **/
    count<T extends BookSubjectCountArgs>(
      args?: Subset<T, BookSubjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookSubjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookSubjectAggregateArgs>(args: Subset<T, BookSubjectAggregateArgs>): Prisma.PrismaPromise<GetBookSubjectAggregateType<T>>

    /**
     * Group by BookSubject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookSubjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookSubjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookSubjectGroupByArgs['orderBy'] }
        : { orderBy?: BookSubjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookSubjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookSubjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookSubject model
   */
  readonly fields: BookSubjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookSubject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookSubjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    book<T extends BookDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookDefaultArgs<ExtArgs>>): Prisma__BookClient<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookSubject model
   */
  interface BookSubjectFieldRefs {
    readonly id: FieldRef<"BookSubject", 'Int'>
    readonly bookId: FieldRef<"BookSubject", 'String'>
    readonly subjectId: FieldRef<"BookSubject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BookSubject findUnique
   */
  export type BookSubjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter, which BookSubject to fetch.
     */
    where: BookSubjectWhereUniqueInput
  }

  /**
   * BookSubject findUniqueOrThrow
   */
  export type BookSubjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter, which BookSubject to fetch.
     */
    where: BookSubjectWhereUniqueInput
  }

  /**
   * BookSubject findFirst
   */
  export type BookSubjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter, which BookSubject to fetch.
     */
    where?: BookSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSubjects to fetch.
     */
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookSubjects.
     */
    cursor?: BookSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookSubjects.
     */
    distinct?: BookSubjectScalarFieldEnum | BookSubjectScalarFieldEnum[]
  }

  /**
   * BookSubject findFirstOrThrow
   */
  export type BookSubjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter, which BookSubject to fetch.
     */
    where?: BookSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSubjects to fetch.
     */
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookSubjects.
     */
    cursor?: BookSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSubjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookSubjects.
     */
    distinct?: BookSubjectScalarFieldEnum | BookSubjectScalarFieldEnum[]
  }

  /**
   * BookSubject findMany
   */
  export type BookSubjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter, which BookSubjects to fetch.
     */
    where?: BookSubjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookSubjects to fetch.
     */
    orderBy?: BookSubjectOrderByWithRelationInput | BookSubjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookSubjects.
     */
    cursor?: BookSubjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookSubjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookSubjects.
     */
    skip?: number
    distinct?: BookSubjectScalarFieldEnum | BookSubjectScalarFieldEnum[]
  }

  /**
   * BookSubject create
   */
  export type BookSubjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * The data needed to create a BookSubject.
     */
    data: XOR<BookSubjectCreateInput, BookSubjectUncheckedCreateInput>
  }

  /**
   * BookSubject createMany
   */
  export type BookSubjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookSubjects.
     */
    data: BookSubjectCreateManyInput | BookSubjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookSubject createManyAndReturn
   */
  export type BookSubjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * The data used to create many BookSubjects.
     */
    data: BookSubjectCreateManyInput | BookSubjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookSubject update
   */
  export type BookSubjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * The data needed to update a BookSubject.
     */
    data: XOR<BookSubjectUpdateInput, BookSubjectUncheckedUpdateInput>
    /**
     * Choose, which BookSubject to update.
     */
    where: BookSubjectWhereUniqueInput
  }

  /**
   * BookSubject updateMany
   */
  export type BookSubjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookSubjects.
     */
    data: XOR<BookSubjectUpdateManyMutationInput, BookSubjectUncheckedUpdateManyInput>
    /**
     * Filter which BookSubjects to update
     */
    where?: BookSubjectWhereInput
    /**
     * Limit how many BookSubjects to update.
     */
    limit?: number
  }

  /**
   * BookSubject updateManyAndReturn
   */
  export type BookSubjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * The data used to update BookSubjects.
     */
    data: XOR<BookSubjectUpdateManyMutationInput, BookSubjectUncheckedUpdateManyInput>
    /**
     * Filter which BookSubjects to update
     */
    where?: BookSubjectWhereInput
    /**
     * Limit how many BookSubjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookSubject upsert
   */
  export type BookSubjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * The filter to search for the BookSubject to update in case it exists.
     */
    where: BookSubjectWhereUniqueInput
    /**
     * In case the BookSubject found by the `where` argument doesn't exist, create a new BookSubject with this data.
     */
    create: XOR<BookSubjectCreateInput, BookSubjectUncheckedCreateInput>
    /**
     * In case the BookSubject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookSubjectUpdateInput, BookSubjectUncheckedUpdateInput>
  }

  /**
   * BookSubject delete
   */
  export type BookSubjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
    /**
     * Filter which BookSubject to delete.
     */
    where: BookSubjectWhereUniqueInput
  }

  /**
   * BookSubject deleteMany
   */
  export type BookSubjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookSubjects to delete
     */
    where?: BookSubjectWhereInput
    /**
     * Limit how many BookSubjects to delete.
     */
    limit?: number
  }

  /**
   * BookSubject without action
   */
  export type BookSubjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookSubject
     */
    select?: BookSubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookSubject
     */
    omit?: BookSubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookSubjectInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    recipientId: number | null
    senderId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    recipientId: number | null
    senderId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    recipientId: number | null
    senderId: number | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    title: string | null
    message: string | null
    isRead: boolean | null
    recipientId: number | null
    senderId: number | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    isRead: number
    recipientId: number
    senderId: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isRead?: true
    recipientId?: true
    senderId?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isRead?: true
    recipientId?: true
    senderId?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    isRead?: true
    recipientId?: true
    senderId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    title: string
    message: string
    isRead: boolean
    recipientId: number
    senderId: number | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    recipientId?: boolean
    senderId?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    recipientId?: boolean
    senderId?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    recipientId?: boolean
    senderId?: boolean
    createdAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    recipientId?: boolean
    senderId?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "message" | "isRead" | "recipientId" | "senderId" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | Notification$senderArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      message: string
      isRead: boolean
      recipientId: number
      senderId: number | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly recipientId: FieldRef<"Notification", 'Int'>
    readonly senderId: FieldRef<"Notification", 'Int'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    subjectId: string | null
    createdAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    subjectId: string | null
    createdAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    title: number
    content: number
    subjectId: number
    createdAt: number
    _all: number
  }


  export type ChapterMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subjectId?: true
    createdAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subjectId?: true
    createdAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subjectId?: true
    createdAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: string
    title: string
    content: string | null
    subjectId: string
    createdAt: Date
    _count: ChapterCountAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subjectId?: boolean
    createdAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subjectId?: boolean
    createdAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subjectId?: boolean
    createdAt?: boolean
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    subjectId?: boolean
    createdAt?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "subjectId" | "createdAt", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subject?: boolean | SubjectDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      subject: Prisma.$SubjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      subjectId: string
      createdAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subject<T extends SubjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubjectDefaultArgs<ExtArgs>>): Prisma__SubjectClient<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'String'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly content: FieldRef<"Chapter", 'String'>
    readonly subjectId: FieldRef<"Chapter", 'String'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model QRCode
   */

  export type AggregateQRCode = {
    _count: QRCodeCountAggregateOutputType | null
    _avg: QRCodeAvgAggregateOutputType | null
    _sum: QRCodeSumAggregateOutputType | null
    _min: QRCodeMinAggregateOutputType | null
    _max: QRCodeMaxAggregateOutputType | null
  }

  export type QRCodeAvgAggregateOutputType = {
    addedById: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type QRCodeSumAggregateOutputType = {
    addedById: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type QRCodeMinAggregateOutputType = {
    qrCode: string | null
    addedById: number | null
    createdById: number | null
    updatedById: number | null
    qrContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QRCodeMaxAggregateOutputType = {
    qrCode: string | null
    addedById: number | null
    createdById: number | null
    updatedById: number | null
    qrContent: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QRCodeCountAggregateOutputType = {
    qrCode: number
    addedById: number
    createdById: number
    updatedById: number
    qrContent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QRCodeAvgAggregateInputType = {
    addedById?: true
    createdById?: true
    updatedById?: true
  }

  export type QRCodeSumAggregateInputType = {
    addedById?: true
    createdById?: true
    updatedById?: true
  }

  export type QRCodeMinAggregateInputType = {
    qrCode?: true
    addedById?: true
    createdById?: true
    updatedById?: true
    qrContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QRCodeMaxAggregateInputType = {
    qrCode?: true
    addedById?: true
    createdById?: true
    updatedById?: true
    qrContent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QRCodeCountAggregateInputType = {
    qrCode?: true
    addedById?: true
    createdById?: true
    updatedById?: true
    qrContent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QRCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCode to aggregate.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QRCodes
    **/
    _count?: true | QRCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QRCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QRCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QRCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QRCodeMaxAggregateInputType
  }

  export type GetQRCodeAggregateType<T extends QRCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateQRCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQRCode[P]>
      : GetScalarType<T[P], AggregateQRCode[P]>
  }




  export type QRCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QRCodeWhereInput
    orderBy?: QRCodeOrderByWithAggregationInput | QRCodeOrderByWithAggregationInput[]
    by: QRCodeScalarFieldEnum[] | QRCodeScalarFieldEnum
    having?: QRCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QRCodeCountAggregateInputType | true
    _avg?: QRCodeAvgAggregateInputType
    _sum?: QRCodeSumAggregateInputType
    _min?: QRCodeMinAggregateInputType
    _max?: QRCodeMaxAggregateInputType
  }

  export type QRCodeGroupByOutputType = {
    qrCode: string
    addedById: number
    createdById: number | null
    updatedById: number | null
    qrContent: string
    createdAt: Date
    updatedAt: Date
    _count: QRCodeCountAggregateOutputType | null
    _avg: QRCodeAvgAggregateOutputType | null
    _sum: QRCodeSumAggregateOutputType | null
    _min: QRCodeMinAggregateOutputType | null
    _max: QRCodeMaxAggregateOutputType | null
  }

  type GetQRCodeGroupByPayload<T extends QRCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QRCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QRCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QRCodeGroupByOutputType[P]>
            : GetScalarType<T[P], QRCodeGroupByOutputType[P]>
        }
      >
    >


  export type QRCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    qrCode?: boolean
    addedById?: boolean
    createdById?: boolean
    updatedById?: boolean
    qrContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
    redirects?: boolean | QRCode$redirectsArgs<ExtArgs>
    _count?: boolean | QRCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    qrCode?: boolean
    addedById?: boolean
    createdById?: boolean
    updatedById?: boolean
    qrContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    qrCode?: boolean
    addedById?: boolean
    createdById?: boolean
    updatedById?: boolean
    qrContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["qRCode"]>

  export type QRCodeSelectScalar = {
    qrCode?: boolean
    addedById?: boolean
    createdById?: boolean
    updatedById?: boolean
    qrContent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QRCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"qrCode" | "addedById" | "createdById" | "updatedById" | "qrContent" | "createdAt" | "updatedAt", ExtArgs["result"]["qRCode"]>
  export type QRCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
    redirects?: boolean | QRCode$redirectsArgs<ExtArgs>
    _count?: boolean | QRCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QRCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
  }
  export type QRCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | UserDefaultArgs<ExtArgs>
    createdBy?: boolean | QRCode$createdByArgs<ExtArgs>
    updatedBy?: boolean | QRCode$updatedByArgs<ExtArgs>
  }

  export type $QRCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QRCode"
    objects: {
      addedBy: Prisma.$UserPayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
      redirects: Prisma.$RedirectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      qrCode: string
      addedById: number
      createdById: number | null
      updatedById: number | null
      qrContent: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qRCode"]>
    composites: {}
  }

  type QRCodeGetPayload<S extends boolean | null | undefined | QRCodeDefaultArgs> = $Result.GetResult<Prisma.$QRCodePayload, S>

  type QRCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QRCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QRCodeCountAggregateInputType | true
    }

  export interface QRCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QRCode'], meta: { name: 'QRCode' } }
    /**
     * Find zero or one QRCode that matches the filter.
     * @param {QRCodeFindUniqueArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QRCodeFindUniqueArgs>(args: SelectSubset<T, QRCodeFindUniqueArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QRCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QRCodeFindUniqueOrThrowArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QRCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, QRCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindFirstArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QRCodeFindFirstArgs>(args?: SelectSubset<T, QRCodeFindFirstArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QRCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindFirstOrThrowArgs} args - Arguments to find a QRCode
     * @example
     * // Get one QRCode
     * const qRCode = await prisma.qRCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QRCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, QRCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QRCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QRCodes
     * const qRCodes = await prisma.qRCode.findMany()
     * 
     * // Get first 10 QRCodes
     * const qRCodes = await prisma.qRCode.findMany({ take: 10 })
     * 
     * // Only select the `qrCode`
     * const qRCodeWithQrCodeOnly = await prisma.qRCode.findMany({ select: { qrCode: true } })
     * 
     */
    findMany<T extends QRCodeFindManyArgs>(args?: SelectSubset<T, QRCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QRCode.
     * @param {QRCodeCreateArgs} args - Arguments to create a QRCode.
     * @example
     * // Create one QRCode
     * const QRCode = await prisma.qRCode.create({
     *   data: {
     *     // ... data to create a QRCode
     *   }
     * })
     * 
     */
    create<T extends QRCodeCreateArgs>(args: SelectSubset<T, QRCodeCreateArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QRCodes.
     * @param {QRCodeCreateManyArgs} args - Arguments to create many QRCodes.
     * @example
     * // Create many QRCodes
     * const qRCode = await prisma.qRCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QRCodeCreateManyArgs>(args?: SelectSubset<T, QRCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QRCodes and returns the data saved in the database.
     * @param {QRCodeCreateManyAndReturnArgs} args - Arguments to create many QRCodes.
     * @example
     * // Create many QRCodes
     * const qRCode = await prisma.qRCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QRCodes and only return the `qrCode`
     * const qRCodeWithQrCodeOnly = await prisma.qRCode.createManyAndReturn({
     *   select: { qrCode: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QRCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, QRCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QRCode.
     * @param {QRCodeDeleteArgs} args - Arguments to delete one QRCode.
     * @example
     * // Delete one QRCode
     * const QRCode = await prisma.qRCode.delete({
     *   where: {
     *     // ... filter to delete one QRCode
     *   }
     * })
     * 
     */
    delete<T extends QRCodeDeleteArgs>(args: SelectSubset<T, QRCodeDeleteArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QRCode.
     * @param {QRCodeUpdateArgs} args - Arguments to update one QRCode.
     * @example
     * // Update one QRCode
     * const qRCode = await prisma.qRCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QRCodeUpdateArgs>(args: SelectSubset<T, QRCodeUpdateArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QRCodes.
     * @param {QRCodeDeleteManyArgs} args - Arguments to filter QRCodes to delete.
     * @example
     * // Delete a few QRCodes
     * const { count } = await prisma.qRCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QRCodeDeleteManyArgs>(args?: SelectSubset<T, QRCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QRCodes
     * const qRCode = await prisma.qRCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QRCodeUpdateManyArgs>(args: SelectSubset<T, QRCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QRCodes and returns the data updated in the database.
     * @param {QRCodeUpdateManyAndReturnArgs} args - Arguments to update many QRCodes.
     * @example
     * // Update many QRCodes
     * const qRCode = await prisma.qRCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QRCodes and only return the `qrCode`
     * const qRCodeWithQrCodeOnly = await prisma.qRCode.updateManyAndReturn({
     *   select: { qrCode: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QRCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, QRCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QRCode.
     * @param {QRCodeUpsertArgs} args - Arguments to update or create a QRCode.
     * @example
     * // Update or create a QRCode
     * const qRCode = await prisma.qRCode.upsert({
     *   create: {
     *     // ... data to create a QRCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QRCode we want to update
     *   }
     * })
     */
    upsert<T extends QRCodeUpsertArgs>(args: SelectSubset<T, QRCodeUpsertArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QRCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeCountArgs} args - Arguments to filter QRCodes to count.
     * @example
     * // Count the number of QRCodes
     * const count = await prisma.qRCode.count({
     *   where: {
     *     // ... the filter for the QRCodes we want to count
     *   }
     * })
    **/
    count<T extends QRCodeCountArgs>(
      args?: Subset<T, QRCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QRCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QRCodeAggregateArgs>(args: Subset<T, QRCodeAggregateArgs>): Prisma.PrismaPromise<GetQRCodeAggregateType<T>>

    /**
     * Group by QRCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QRCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QRCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QRCodeGroupByArgs['orderBy'] }
        : { orderBy?: QRCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QRCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQRCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QRCode model
   */
  readonly fields: QRCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QRCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QRCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends QRCode$createdByArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends QRCode$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    redirects<T extends QRCode$redirectsArgs<ExtArgs> = {}>(args?: Subset<T, QRCode$redirectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QRCode model
   */
  interface QRCodeFieldRefs {
    readonly qrCode: FieldRef<"QRCode", 'String'>
    readonly addedById: FieldRef<"QRCode", 'Int'>
    readonly createdById: FieldRef<"QRCode", 'Int'>
    readonly updatedById: FieldRef<"QRCode", 'Int'>
    readonly qrContent: FieldRef<"QRCode", 'String'>
    readonly createdAt: FieldRef<"QRCode", 'DateTime'>
    readonly updatedAt: FieldRef<"QRCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QRCode findUnique
   */
  export type QRCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode findUniqueOrThrow
   */
  export type QRCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode findFirst
   */
  export type QRCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodes.
     */
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode findFirstOrThrow
   */
  export type QRCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCode to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QRCodes.
     */
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode findMany
   */
  export type QRCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter, which QRCodes to fetch.
     */
    where?: QRCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QRCodes to fetch.
     */
    orderBy?: QRCodeOrderByWithRelationInput | QRCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QRCodes.
     */
    cursor?: QRCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QRCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QRCodes.
     */
    skip?: number
    distinct?: QRCodeScalarFieldEnum | QRCodeScalarFieldEnum[]
  }

  /**
   * QRCode create
   */
  export type QRCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a QRCode.
     */
    data: XOR<QRCodeCreateInput, QRCodeUncheckedCreateInput>
  }

  /**
   * QRCode createMany
   */
  export type QRCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QRCodes.
     */
    data: QRCodeCreateManyInput | QRCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QRCode createManyAndReturn
   */
  export type QRCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * The data used to create many QRCodes.
     */
    data: QRCodeCreateManyInput | QRCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRCode update
   */
  export type QRCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a QRCode.
     */
    data: XOR<QRCodeUpdateInput, QRCodeUncheckedUpdateInput>
    /**
     * Choose, which QRCode to update.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode updateMany
   */
  export type QRCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QRCodes.
     */
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyInput>
    /**
     * Filter which QRCodes to update
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to update.
     */
    limit?: number
  }

  /**
   * QRCode updateManyAndReturn
   */
  export type QRCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * The data used to update QRCodes.
     */
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyInput>
    /**
     * Filter which QRCodes to update
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QRCode upsert
   */
  export type QRCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the QRCode to update in case it exists.
     */
    where: QRCodeWhereUniqueInput
    /**
     * In case the QRCode found by the `where` argument doesn't exist, create a new QRCode with this data.
     */
    create: XOR<QRCodeCreateInput, QRCodeUncheckedCreateInput>
    /**
     * In case the QRCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QRCodeUpdateInput, QRCodeUncheckedUpdateInput>
  }

  /**
   * QRCode delete
   */
  export type QRCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
    /**
     * Filter which QRCode to delete.
     */
    where: QRCodeWhereUniqueInput
  }

  /**
   * QRCode deleteMany
   */
  export type QRCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QRCodes to delete
     */
    where?: QRCodeWhereInput
    /**
     * Limit how many QRCodes to delete.
     */
    limit?: number
  }

  /**
   * QRCode.createdBy
   */
  export type QRCode$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * QRCode.updatedBy
   */
  export type QRCode$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * QRCode.redirects
   */
  export type QRCode$redirectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    where?: RedirectWhereInput
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    cursor?: RedirectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * QRCode without action
   */
  export type QRCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QRCode
     */
    select?: QRCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QRCode
     */
    omit?: QRCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QRCodeInclude<ExtArgs> | null
  }


  /**
   * Model Redirect
   */

  export type AggregateRedirect = {
    _count: RedirectCountAggregateOutputType | null
    _avg: RedirectAvgAggregateOutputType | null
    _sum: RedirectSumAggregateOutputType | null
    _min: RedirectMinAggregateOutputType | null
    _max: RedirectMaxAggregateOutputType | null
  }

  export type RedirectAvgAggregateOutputType = {
    id: number | null
  }

  export type RedirectSumAggregateOutputType = {
    id: number | null
  }

  export type RedirectMinAggregateOutputType = {
    id: number | null
    qrCodeId: string | null
    redirect: string | null
  }

  export type RedirectMaxAggregateOutputType = {
    id: number | null
    qrCodeId: string | null
    redirect: string | null
  }

  export type RedirectCountAggregateOutputType = {
    id: number
    qrCodeId: number
    redirect: number
    _all: number
  }


  export type RedirectAvgAggregateInputType = {
    id?: true
  }

  export type RedirectSumAggregateInputType = {
    id?: true
  }

  export type RedirectMinAggregateInputType = {
    id?: true
    qrCodeId?: true
    redirect?: true
  }

  export type RedirectMaxAggregateInputType = {
    id?: true
    qrCodeId?: true
    redirect?: true
  }

  export type RedirectCountAggregateInputType = {
    id?: true
    qrCodeId?: true
    redirect?: true
    _all?: true
  }

  export type RedirectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redirect to aggregate.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redirects
    **/
    _count?: true | RedirectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RedirectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RedirectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedirectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedirectMaxAggregateInputType
  }

  export type GetRedirectAggregateType<T extends RedirectAggregateArgs> = {
        [P in keyof T & keyof AggregateRedirect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedirect[P]>
      : GetScalarType<T[P], AggregateRedirect[P]>
  }




  export type RedirectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedirectWhereInput
    orderBy?: RedirectOrderByWithAggregationInput | RedirectOrderByWithAggregationInput[]
    by: RedirectScalarFieldEnum[] | RedirectScalarFieldEnum
    having?: RedirectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedirectCountAggregateInputType | true
    _avg?: RedirectAvgAggregateInputType
    _sum?: RedirectSumAggregateInputType
    _min?: RedirectMinAggregateInputType
    _max?: RedirectMaxAggregateInputType
  }

  export type RedirectGroupByOutputType = {
    id: number
    qrCodeId: string
    redirect: string
    _count: RedirectCountAggregateOutputType | null
    _avg: RedirectAvgAggregateOutputType | null
    _sum: RedirectSumAggregateOutputType | null
    _min: RedirectMinAggregateOutputType | null
    _max: RedirectMaxAggregateOutputType | null
  }

  type GetRedirectGroupByPayload<T extends RedirectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedirectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedirectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedirectGroupByOutputType[P]>
            : GetScalarType<T[P], RedirectGroupByOutputType[P]>
        }
      >
    >


  export type RedirectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrCodeId?: boolean
    redirect?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrCodeId?: boolean
    redirect?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrCodeId?: boolean
    redirect?: boolean
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redirect"]>

  export type RedirectSelectScalar = {
    id?: boolean
    qrCodeId?: boolean
    redirect?: boolean
  }

  export type RedirectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qrCodeId" | "redirect", ExtArgs["result"]["redirect"]>
  export type RedirectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }
  export type RedirectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }
  export type RedirectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qrCode?: boolean | QRCodeDefaultArgs<ExtArgs>
  }

  export type $RedirectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redirect"
    objects: {
      qrCode: Prisma.$QRCodePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      qrCodeId: string
      redirect: string
    }, ExtArgs["result"]["redirect"]>
    composites: {}
  }

  type RedirectGetPayload<S extends boolean | null | undefined | RedirectDefaultArgs> = $Result.GetResult<Prisma.$RedirectPayload, S>

  type RedirectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RedirectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RedirectCountAggregateInputType | true
    }

  export interface RedirectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redirect'], meta: { name: 'Redirect' } }
    /**
     * Find zero or one Redirect that matches the filter.
     * @param {RedirectFindUniqueArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RedirectFindUniqueArgs>(args: SelectSubset<T, RedirectFindUniqueArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Redirect that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RedirectFindUniqueOrThrowArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RedirectFindUniqueOrThrowArgs>(args: SelectSubset<T, RedirectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redirect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindFirstArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RedirectFindFirstArgs>(args?: SelectSubset<T, RedirectFindFirstArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Redirect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindFirstOrThrowArgs} args - Arguments to find a Redirect
     * @example
     * // Get one Redirect
     * const redirect = await prisma.redirect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RedirectFindFirstOrThrowArgs>(args?: SelectSubset<T, RedirectFindFirstOrThrowArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Redirects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redirects
     * const redirects = await prisma.redirect.findMany()
     * 
     * // Get first 10 Redirects
     * const redirects = await prisma.redirect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redirectWithIdOnly = await prisma.redirect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RedirectFindManyArgs>(args?: SelectSubset<T, RedirectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Redirect.
     * @param {RedirectCreateArgs} args - Arguments to create a Redirect.
     * @example
     * // Create one Redirect
     * const Redirect = await prisma.redirect.create({
     *   data: {
     *     // ... data to create a Redirect
     *   }
     * })
     * 
     */
    create<T extends RedirectCreateArgs>(args: SelectSubset<T, RedirectCreateArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Redirects.
     * @param {RedirectCreateManyArgs} args - Arguments to create many Redirects.
     * @example
     * // Create many Redirects
     * const redirect = await prisma.redirect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RedirectCreateManyArgs>(args?: SelectSubset<T, RedirectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Redirects and returns the data saved in the database.
     * @param {RedirectCreateManyAndReturnArgs} args - Arguments to create many Redirects.
     * @example
     * // Create many Redirects
     * const redirect = await prisma.redirect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Redirects and only return the `id`
     * const redirectWithIdOnly = await prisma.redirect.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RedirectCreateManyAndReturnArgs>(args?: SelectSubset<T, RedirectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Redirect.
     * @param {RedirectDeleteArgs} args - Arguments to delete one Redirect.
     * @example
     * // Delete one Redirect
     * const Redirect = await prisma.redirect.delete({
     *   where: {
     *     // ... filter to delete one Redirect
     *   }
     * })
     * 
     */
    delete<T extends RedirectDeleteArgs>(args: SelectSubset<T, RedirectDeleteArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Redirect.
     * @param {RedirectUpdateArgs} args - Arguments to update one Redirect.
     * @example
     * // Update one Redirect
     * const redirect = await prisma.redirect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RedirectUpdateArgs>(args: SelectSubset<T, RedirectUpdateArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Redirects.
     * @param {RedirectDeleteManyArgs} args - Arguments to filter Redirects to delete.
     * @example
     * // Delete a few Redirects
     * const { count } = await prisma.redirect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RedirectDeleteManyArgs>(args?: SelectSubset<T, RedirectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redirects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redirects
     * const redirect = await prisma.redirect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RedirectUpdateManyArgs>(args: SelectSubset<T, RedirectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redirects and returns the data updated in the database.
     * @param {RedirectUpdateManyAndReturnArgs} args - Arguments to update many Redirects.
     * @example
     * // Update many Redirects
     * const redirect = await prisma.redirect.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Redirects and only return the `id`
     * const redirectWithIdOnly = await prisma.redirect.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RedirectUpdateManyAndReturnArgs>(args: SelectSubset<T, RedirectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Redirect.
     * @param {RedirectUpsertArgs} args - Arguments to update or create a Redirect.
     * @example
     * // Update or create a Redirect
     * const redirect = await prisma.redirect.upsert({
     *   create: {
     *     // ... data to create a Redirect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redirect we want to update
     *   }
     * })
     */
    upsert<T extends RedirectUpsertArgs>(args: SelectSubset<T, RedirectUpsertArgs<ExtArgs>>): Prisma__RedirectClient<$Result.GetResult<Prisma.$RedirectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Redirects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectCountArgs} args - Arguments to filter Redirects to count.
     * @example
     * // Count the number of Redirects
     * const count = await prisma.redirect.count({
     *   where: {
     *     // ... the filter for the Redirects we want to count
     *   }
     * })
    **/
    count<T extends RedirectCountArgs>(
      args?: Subset<T, RedirectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedirectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redirect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedirectAggregateArgs>(args: Subset<T, RedirectAggregateArgs>): Prisma.PrismaPromise<GetRedirectAggregateType<T>>

    /**
     * Group by Redirect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedirectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedirectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedirectGroupByArgs['orderBy'] }
        : { orderBy?: RedirectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedirectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedirectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redirect model
   */
  readonly fields: RedirectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redirect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedirectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    qrCode<T extends QRCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QRCodeDefaultArgs<ExtArgs>>): Prisma__QRCodeClient<$Result.GetResult<Prisma.$QRCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Redirect model
   */
  interface RedirectFieldRefs {
    readonly id: FieldRef<"Redirect", 'Int'>
    readonly qrCodeId: FieldRef<"Redirect", 'String'>
    readonly redirect: FieldRef<"Redirect", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Redirect findUnique
   */
  export type RedirectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect findUniqueOrThrow
   */
  export type RedirectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect findFirst
   */
  export type RedirectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redirects.
     */
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect findFirstOrThrow
   */
  export type RedirectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter, which Redirect to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redirects.
     */
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect findMany
   */
  export type RedirectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter, which Redirects to fetch.
     */
    where?: RedirectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redirects to fetch.
     */
    orderBy?: RedirectOrderByWithRelationInput | RedirectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redirects.
     */
    cursor?: RedirectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redirects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redirects.
     */
    skip?: number
    distinct?: RedirectScalarFieldEnum | RedirectScalarFieldEnum[]
  }

  /**
   * Redirect create
   */
  export type RedirectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * The data needed to create a Redirect.
     */
    data: XOR<RedirectCreateInput, RedirectUncheckedCreateInput>
  }

  /**
   * Redirect createMany
   */
  export type RedirectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redirects.
     */
    data: RedirectCreateManyInput | RedirectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Redirect createManyAndReturn
   */
  export type RedirectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data used to create many Redirects.
     */
    data: RedirectCreateManyInput | RedirectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Redirect update
   */
  export type RedirectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * The data needed to update a Redirect.
     */
    data: XOR<RedirectUpdateInput, RedirectUncheckedUpdateInput>
    /**
     * Choose, which Redirect to update.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect updateMany
   */
  export type RedirectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redirects.
     */
    data: XOR<RedirectUpdateManyMutationInput, RedirectUncheckedUpdateManyInput>
    /**
     * Filter which Redirects to update
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to update.
     */
    limit?: number
  }

  /**
   * Redirect updateManyAndReturn
   */
  export type RedirectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * The data used to update Redirects.
     */
    data: XOR<RedirectUpdateManyMutationInput, RedirectUncheckedUpdateManyInput>
    /**
     * Filter which Redirects to update
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Redirect upsert
   */
  export type RedirectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * The filter to search for the Redirect to update in case it exists.
     */
    where: RedirectWhereUniqueInput
    /**
     * In case the Redirect found by the `where` argument doesn't exist, create a new Redirect with this data.
     */
    create: XOR<RedirectCreateInput, RedirectUncheckedCreateInput>
    /**
     * In case the Redirect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedirectUpdateInput, RedirectUncheckedUpdateInput>
  }

  /**
   * Redirect delete
   */
  export type RedirectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
    /**
     * Filter which Redirect to delete.
     */
    where: RedirectWhereUniqueInput
  }

  /**
   * Redirect deleteMany
   */
  export type RedirectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redirects to delete
     */
    where?: RedirectWhereInput
    /**
     * Limit how many Redirects to delete.
     */
    limit?: number
  }

  /**
   * Redirect without action
   */
  export type RedirectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redirect
     */
    select?: RedirectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Redirect
     */
    omit?: RedirectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RedirectInclude<ExtArgs> | null
  }


  /**
   * Model AcademicYear
   */

  export type AggregateAcademicYear = {
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  export type AcademicYearAvgAggregateOutputType = {
    id: number | null
  }

  export type AcademicYearSumAggregateOutputType = {
    id: number | null
  }

  export type AcademicYearMinAggregateOutputType = {
    id: number | null
    label: string | null
    code: string | null
  }

  export type AcademicYearMaxAggregateOutputType = {
    id: number | null
    label: string | null
    code: string | null
  }

  export type AcademicYearCountAggregateOutputType = {
    id: number
    label: number
    code: number
    _all: number
  }


  export type AcademicYearAvgAggregateInputType = {
    id?: true
  }

  export type AcademicYearSumAggregateInputType = {
    id?: true
  }

  export type AcademicYearMinAggregateInputType = {
    id?: true
    label?: true
    code?: true
  }

  export type AcademicYearMaxAggregateInputType = {
    id?: true
    label?: true
    code?: true
  }

  export type AcademicYearCountAggregateInputType = {
    id?: true
    label?: true
    code?: true
    _all?: true
  }

  export type AcademicYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYear to aggregate.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicYears
    **/
    _count?: true | AcademicYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicYearMaxAggregateInputType
  }

  export type GetAcademicYearAggregateType<T extends AcademicYearAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicYear[P]>
      : GetScalarType<T[P], AggregateAcademicYear[P]>
  }




  export type AcademicYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithAggregationInput | AcademicYearOrderByWithAggregationInput[]
    by: AcademicYearScalarFieldEnum[] | AcademicYearScalarFieldEnum
    having?: AcademicYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicYearCountAggregateInputType | true
    _avg?: AcademicYearAvgAggregateInputType
    _sum?: AcademicYearSumAggregateInputType
    _min?: AcademicYearMinAggregateInputType
    _max?: AcademicYearMaxAggregateInputType
  }

  export type AcademicYearGroupByOutputType = {
    id: number
    label: string
    code: string
    _count: AcademicYearCountAggregateOutputType | null
    _avg: AcademicYearAvgAggregateOutputType | null
    _sum: AcademicYearSumAggregateOutputType | null
    _min: AcademicYearMinAggregateOutputType | null
    _max: AcademicYearMaxAggregateOutputType | null
  }

  type GetAcademicYearGroupByPayload<T extends AcademicYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicYearGroupByOutputType[P]>
        }
      >
    >


  export type AcademicYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    code?: boolean
    books?: boolean | AcademicYear$booksArgs<ExtArgs>
    subjects?: boolean | AcademicYear$subjectsArgs<ExtArgs>
    branchs?: boolean | AcademicYear$branchsArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    code?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    code?: boolean
  }, ExtArgs["result"]["academicYear"]>

  export type AcademicYearSelectScalar = {
    id?: boolean
    label?: boolean
    code?: boolean
  }

  export type AcademicYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "code", ExtArgs["result"]["academicYear"]>
  export type AcademicYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    books?: boolean | AcademicYear$booksArgs<ExtArgs>
    subjects?: boolean | AcademicYear$subjectsArgs<ExtArgs>
    branchs?: boolean | AcademicYear$branchsArgs<ExtArgs>
    _count?: boolean | AcademicYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AcademicYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AcademicYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AcademicYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicYear"
    objects: {
      books: Prisma.$BookPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
      branchs: Prisma.$BranchPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label: string
      code: string
    }, ExtArgs["result"]["academicYear"]>
    composites: {}
  }

  type AcademicYearGetPayload<S extends boolean | null | undefined | AcademicYearDefaultArgs> = $Result.GetResult<Prisma.$AcademicYearPayload, S>

  type AcademicYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AcademicYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AcademicYearCountAggregateInputType | true
    }

  export interface AcademicYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicYear'], meta: { name: 'AcademicYear' } }
    /**
     * Find zero or one AcademicYear that matches the filter.
     * @param {AcademicYearFindUniqueArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicYearFindUniqueArgs>(args: SelectSubset<T, AcademicYearFindUniqueArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AcademicYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AcademicYearFindUniqueOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicYearFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicYearFindFirstArgs>(args?: SelectSubset<T, AcademicYearFindFirstArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AcademicYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindFirstOrThrowArgs} args - Arguments to find a AcademicYear
     * @example
     * // Get one AcademicYear
     * const academicYear = await prisma.academicYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicYearFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AcademicYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicYears
     * const academicYears = await prisma.academicYear.findMany()
     * 
     * // Get first 10 AcademicYears
     * const academicYears = await prisma.academicYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicYearFindManyArgs>(args?: SelectSubset<T, AcademicYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AcademicYear.
     * @param {AcademicYearCreateArgs} args - Arguments to create a AcademicYear.
     * @example
     * // Create one AcademicYear
     * const AcademicYear = await prisma.academicYear.create({
     *   data: {
     *     // ... data to create a AcademicYear
     *   }
     * })
     * 
     */
    create<T extends AcademicYearCreateArgs>(args: SelectSubset<T, AcademicYearCreateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AcademicYears.
     * @param {AcademicYearCreateManyArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicYearCreateManyArgs>(args?: SelectSubset<T, AcademicYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicYears and returns the data saved in the database.
     * @param {AcademicYearCreateManyAndReturnArgs} args - Arguments to create many AcademicYears.
     * @example
     * // Create many AcademicYears
     * const academicYear = await prisma.academicYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicYearCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AcademicYear.
     * @param {AcademicYearDeleteArgs} args - Arguments to delete one AcademicYear.
     * @example
     * // Delete one AcademicYear
     * const AcademicYear = await prisma.academicYear.delete({
     *   where: {
     *     // ... filter to delete one AcademicYear
     *   }
     * })
     * 
     */
    delete<T extends AcademicYearDeleteArgs>(args: SelectSubset<T, AcademicYearDeleteArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AcademicYear.
     * @param {AcademicYearUpdateArgs} args - Arguments to update one AcademicYear.
     * @example
     * // Update one AcademicYear
     * const academicYear = await prisma.academicYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicYearUpdateArgs>(args: SelectSubset<T, AcademicYearUpdateArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AcademicYears.
     * @param {AcademicYearDeleteManyArgs} args - Arguments to filter AcademicYears to delete.
     * @example
     * // Delete a few AcademicYears
     * const { count } = await prisma.academicYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicYearDeleteManyArgs>(args?: SelectSubset<T, AcademicYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicYearUpdateManyArgs>(args: SelectSubset<T, AcademicYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicYears and returns the data updated in the database.
     * @param {AcademicYearUpdateManyAndReturnArgs} args - Arguments to update many AcademicYears.
     * @example
     * // Update many AcademicYears
     * const academicYear = await prisma.academicYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AcademicYears and only return the `id`
     * const academicYearWithIdOnly = await prisma.academicYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AcademicYearUpdateManyAndReturnArgs>(args: SelectSubset<T, AcademicYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AcademicYear.
     * @param {AcademicYearUpsertArgs} args - Arguments to update or create a AcademicYear.
     * @example
     * // Update or create a AcademicYear
     * const academicYear = await prisma.academicYear.upsert({
     *   create: {
     *     // ... data to create a AcademicYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicYear we want to update
     *   }
     * })
     */
    upsert<T extends AcademicYearUpsertArgs>(args: SelectSubset<T, AcademicYearUpsertArgs<ExtArgs>>): Prisma__AcademicYearClient<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AcademicYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearCountArgs} args - Arguments to filter AcademicYears to count.
     * @example
     * // Count the number of AcademicYears
     * const count = await prisma.academicYear.count({
     *   where: {
     *     // ... the filter for the AcademicYears we want to count
     *   }
     * })
    **/
    count<T extends AcademicYearCountArgs>(
      args?: Subset<T, AcademicYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicYearAggregateArgs>(args: Subset<T, AcademicYearAggregateArgs>): Prisma.PrismaPromise<GetAcademicYearAggregateType<T>>

    /**
     * Group by AcademicYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicYearGroupByArgs['orderBy'] }
        : { orderBy?: AcademicYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicYear model
   */
  readonly fields: AcademicYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    books<T extends AcademicYear$booksArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends AcademicYear$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branchs<T extends AcademicYear$branchsArgs<ExtArgs> = {}>(args?: Subset<T, AcademicYear$branchsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicYear model
   */
  interface AcademicYearFieldRefs {
    readonly id: FieldRef<"AcademicYear", 'Int'>
    readonly label: FieldRef<"AcademicYear", 'String'>
    readonly code: FieldRef<"AcademicYear", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AcademicYear findUnique
   */
  export type AcademicYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findUniqueOrThrow
   */
  export type AcademicYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear findFirst
   */
  export type AcademicYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findFirstOrThrow
   */
  export type AcademicYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYear to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicYears.
     */
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear findMany
   */
  export type AcademicYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter, which AcademicYears to fetch.
     */
    where?: AcademicYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicYears to fetch.
     */
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicYears.
     */
    cursor?: AcademicYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicYears.
     */
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * AcademicYear create
   */
  export type AcademicYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicYear.
     */
    data: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
  }

  /**
   * AcademicYear createMany
   */
  export type AcademicYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear createManyAndReturn
   */
  export type AcademicYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to create many AcademicYears.
     */
    data: AcademicYearCreateManyInput | AcademicYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AcademicYear update
   */
  export type AcademicYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicYear.
     */
    data: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
    /**
     * Choose, which AcademicYear to update.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear updateMany
   */
  export type AcademicYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear updateManyAndReturn
   */
  export type AcademicYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * The data used to update AcademicYears.
     */
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyInput>
    /**
     * Filter which AcademicYears to update
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to update.
     */
    limit?: number
  }

  /**
   * AcademicYear upsert
   */
  export type AcademicYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicYear to update in case it exists.
     */
    where: AcademicYearWhereUniqueInput
    /**
     * In case the AcademicYear found by the `where` argument doesn't exist, create a new AcademicYear with this data.
     */
    create: XOR<AcademicYearCreateInput, AcademicYearUncheckedCreateInput>
    /**
     * In case the AcademicYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicYearUpdateInput, AcademicYearUncheckedUpdateInput>
  }

  /**
   * AcademicYear delete
   */
  export type AcademicYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    /**
     * Filter which AcademicYear to delete.
     */
    where: AcademicYearWhereUniqueInput
  }

  /**
   * AcademicYear deleteMany
   */
  export type AcademicYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicYears to delete
     */
    where?: AcademicYearWhereInput
    /**
     * Limit how many AcademicYears to delete.
     */
    limit?: number
  }

  /**
   * AcademicYear.books
   */
  export type AcademicYear$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * AcademicYear.subjects
   */
  export type AcademicYear$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * AcademicYear.branchs
   */
  export type AcademicYear$branchsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    cursor?: BranchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * AcademicYear without action
   */
  export type AcademicYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
  }


  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchSumAggregateOutputType = {
    id: number | null
  }

  export type BranchMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
  }

  export type BranchCountAggregateOutputType = {
    id: number
    name: number
    location: number
    createdAt: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    id?: true
  }

  export type BranchSumAggregateInputType = {
    id?: true
  }

  export type BranchMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
  }

  export type BranchMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
  }

  export type BranchCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    id: number
    name: string
    location: string | null
    createdAt: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
    years?: boolean | Branch$yearsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    books?: boolean | Branch$booksArgs<ExtArgs>
    subjects?: boolean | Branch$subjectsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["branch"]>

  export type BranchSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "createdAt", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    years?: boolean | Branch$yearsArgs<ExtArgs>
    users?: boolean | Branch$usersArgs<ExtArgs>
    books?: boolean | Branch$booksArgs<ExtArgs>
    subjects?: boolean | Branch$subjectsArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BranchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BranchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      years: Prisma.$AcademicYearPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      books: Prisma.$BookPayload<ExtArgs>[]
      subjects: Prisma.$SubjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string | null
      createdAt: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchWithIdOnly = await prisma.branch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Branches and returns the data saved in the database.
     * @param {BranchCreateManyAndReturnArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BranchCreateManyAndReturnArgs>(args?: SelectSubset<T, BranchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches and returns the data updated in the database.
     * @param {BranchUpdateManyAndReturnArgs} args - Arguments to update many Branches.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Branches and only return the `id`
     * const branchWithIdOnly = await prisma.branch.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BranchUpdateManyAndReturnArgs>(args: SelectSubset<T, BranchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    years<T extends Branch$yearsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$yearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Branch$usersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    books<T extends Branch$booksArgs<ExtArgs> = {}>(args?: Subset<T, Branch$booksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subjects<T extends Branch$subjectsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$subjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly id: FieldRef<"Branch", 'Int'>
    readonly name: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly createdAt: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch createManyAndReturn
   */
  export type BranchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch updateManyAndReturn
   */
  export type BranchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.years
   */
  export type Branch$yearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicYear
     */
    select?: AcademicYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AcademicYear
     */
    omit?: AcademicYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicYearInclude<ExtArgs> | null
    where?: AcademicYearWhereInput
    orderBy?: AcademicYearOrderByWithRelationInput | AcademicYearOrderByWithRelationInput[]
    cursor?: AcademicYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicYearScalarFieldEnum | AcademicYearScalarFieldEnum[]
  }

  /**
   * Branch.users
   */
  export type Branch$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Branch.books
   */
  export type Branch$booksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Book
     */
    select?: BookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Book
     */
    omit?: BookOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookInclude<ExtArgs> | null
    where?: BookWhereInput
    orderBy?: BookOrderByWithRelationInput | BookOrderByWithRelationInput[]
    cursor?: BookWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookScalarFieldEnum | BookScalarFieldEnum[]
  }

  /**
   * Branch.subjects
   */
  export type Branch$subjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subject
     */
    select?: SubjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subject
     */
    omit?: SubjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubjectInclude<ExtArgs> | null
    where?: SubjectWhereInput
    orderBy?: SubjectOrderByWithRelationInput | SubjectOrderByWithRelationInput[]
    cursor?: SubjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubjectScalarFieldEnum | SubjectScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model WhitelistedUrl
   */

  export type AggregateWhitelistedUrl = {
    _count: WhitelistedUrlCountAggregateOutputType | null
    _avg: WhitelistedUrlAvgAggregateOutputType | null
    _sum: WhitelistedUrlSumAggregateOutputType | null
    _min: WhitelistedUrlMinAggregateOutputType | null
    _max: WhitelistedUrlMaxAggregateOutputType | null
  }

  export type WhitelistedUrlAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type WhitelistedUrlSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type WhitelistedUrlMinAggregateOutputType = {
    id: number | null
    url: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type WhitelistedUrlMaxAggregateOutputType = {
    id: number | null
    url: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type WhitelistedUrlCountAggregateOutputType = {
    id: number
    url: number
    domain: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type WhitelistedUrlAvgAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type WhitelistedUrlSumAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type WhitelistedUrlMinAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type WhitelistedUrlMaxAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type WhitelistedUrlCountAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type WhitelistedUrlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistedUrl to aggregate.
     */
    where?: WhitelistedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistedUrls to fetch.
     */
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhitelistedUrls
    **/
    _count?: true | WhitelistedUrlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhitelistedUrlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhitelistedUrlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistedUrlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistedUrlMaxAggregateInputType
  }

  export type GetWhitelistedUrlAggregateType<T extends WhitelistedUrlAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelistedUrl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelistedUrl[P]>
      : GetScalarType<T[P], AggregateWhitelistedUrl[P]>
  }




  export type WhitelistedUrlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistedUrlWhereInput
    orderBy?: WhitelistedUrlOrderByWithAggregationInput | WhitelistedUrlOrderByWithAggregationInput[]
    by: WhitelistedUrlScalarFieldEnum[] | WhitelistedUrlScalarFieldEnum
    having?: WhitelistedUrlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistedUrlCountAggregateInputType | true
    _avg?: WhitelistedUrlAvgAggregateInputType
    _sum?: WhitelistedUrlSumAggregateInputType
    _min?: WhitelistedUrlMinAggregateInputType
    _max?: WhitelistedUrlMaxAggregateInputType
  }

  export type WhitelistedUrlGroupByOutputType = {
    id: number
    url: string
    domain: string
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: WhitelistedUrlCountAggregateOutputType | null
    _avg: WhitelistedUrlAvgAggregateOutputType | null
    _sum: WhitelistedUrlSumAggregateOutputType | null
    _min: WhitelistedUrlMinAggregateOutputType | null
    _max: WhitelistedUrlMaxAggregateOutputType | null
  }

  type GetWhitelistedUrlGroupByPayload<T extends WhitelistedUrlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistedUrlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistedUrlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistedUrlGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistedUrlGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistedUrlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistedUrl"]>

  export type WhitelistedUrlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistedUrl"]>

  export type WhitelistedUrlSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["whitelistedUrl"]>

  export type WhitelistedUrlSelectScalar = {
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type WhitelistedUrlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "domain" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["whitelistedUrl"]>
  export type WhitelistedUrlInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }
  export type WhitelistedUrlIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }
  export type WhitelistedUrlIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | WhitelistedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | WhitelistedUrl$updatedByArgs<ExtArgs>
  }

  export type $WhitelistedUrlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhitelistedUrl"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      domain: string
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["whitelistedUrl"]>
    composites: {}
  }

  type WhitelistedUrlGetPayload<S extends boolean | null | undefined | WhitelistedUrlDefaultArgs> = $Result.GetResult<Prisma.$WhitelistedUrlPayload, S>

  type WhitelistedUrlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhitelistedUrlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhitelistedUrlCountAggregateInputType | true
    }

  export interface WhitelistedUrlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhitelistedUrl'], meta: { name: 'WhitelistedUrl' } }
    /**
     * Find zero or one WhitelistedUrl that matches the filter.
     * @param {WhitelistedUrlFindUniqueArgs} args - Arguments to find a WhitelistedUrl
     * @example
     * // Get one WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhitelistedUrlFindUniqueArgs>(args: SelectSubset<T, WhitelistedUrlFindUniqueArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhitelistedUrl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhitelistedUrlFindUniqueOrThrowArgs} args - Arguments to find a WhitelistedUrl
     * @example
     * // Get one WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhitelistedUrlFindUniqueOrThrowArgs>(args: SelectSubset<T, WhitelistedUrlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhitelistedUrl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlFindFirstArgs} args - Arguments to find a WhitelistedUrl
     * @example
     * // Get one WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhitelistedUrlFindFirstArgs>(args?: SelectSubset<T, WhitelistedUrlFindFirstArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhitelistedUrl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlFindFirstOrThrowArgs} args - Arguments to find a WhitelistedUrl
     * @example
     * // Get one WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhitelistedUrlFindFirstOrThrowArgs>(args?: SelectSubset<T, WhitelistedUrlFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhitelistedUrls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhitelistedUrls
     * const whitelistedUrls = await prisma.whitelistedUrl.findMany()
     * 
     * // Get first 10 WhitelistedUrls
     * const whitelistedUrls = await prisma.whitelistedUrl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistedUrlWithIdOnly = await prisma.whitelistedUrl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhitelistedUrlFindManyArgs>(args?: SelectSubset<T, WhitelistedUrlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhitelistedUrl.
     * @param {WhitelistedUrlCreateArgs} args - Arguments to create a WhitelistedUrl.
     * @example
     * // Create one WhitelistedUrl
     * const WhitelistedUrl = await prisma.whitelistedUrl.create({
     *   data: {
     *     // ... data to create a WhitelistedUrl
     *   }
     * })
     * 
     */
    create<T extends WhitelistedUrlCreateArgs>(args: SelectSubset<T, WhitelistedUrlCreateArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhitelistedUrls.
     * @param {WhitelistedUrlCreateManyArgs} args - Arguments to create many WhitelistedUrls.
     * @example
     * // Create many WhitelistedUrls
     * const whitelistedUrl = await prisma.whitelistedUrl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhitelistedUrlCreateManyArgs>(args?: SelectSubset<T, WhitelistedUrlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhitelistedUrls and returns the data saved in the database.
     * @param {WhitelistedUrlCreateManyAndReturnArgs} args - Arguments to create many WhitelistedUrls.
     * @example
     * // Create many WhitelistedUrls
     * const whitelistedUrl = await prisma.whitelistedUrl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhitelistedUrls and only return the `id`
     * const whitelistedUrlWithIdOnly = await prisma.whitelistedUrl.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhitelistedUrlCreateManyAndReturnArgs>(args?: SelectSubset<T, WhitelistedUrlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhitelistedUrl.
     * @param {WhitelistedUrlDeleteArgs} args - Arguments to delete one WhitelistedUrl.
     * @example
     * // Delete one WhitelistedUrl
     * const WhitelistedUrl = await prisma.whitelistedUrl.delete({
     *   where: {
     *     // ... filter to delete one WhitelistedUrl
     *   }
     * })
     * 
     */
    delete<T extends WhitelistedUrlDeleteArgs>(args: SelectSubset<T, WhitelistedUrlDeleteArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhitelistedUrl.
     * @param {WhitelistedUrlUpdateArgs} args - Arguments to update one WhitelistedUrl.
     * @example
     * // Update one WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhitelistedUrlUpdateArgs>(args: SelectSubset<T, WhitelistedUrlUpdateArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhitelistedUrls.
     * @param {WhitelistedUrlDeleteManyArgs} args - Arguments to filter WhitelistedUrls to delete.
     * @example
     * // Delete a few WhitelistedUrls
     * const { count } = await prisma.whitelistedUrl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhitelistedUrlDeleteManyArgs>(args?: SelectSubset<T, WhitelistedUrlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistedUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhitelistedUrls
     * const whitelistedUrl = await prisma.whitelistedUrl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhitelistedUrlUpdateManyArgs>(args: SelectSubset<T, WhitelistedUrlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhitelistedUrls and returns the data updated in the database.
     * @param {WhitelistedUrlUpdateManyAndReturnArgs} args - Arguments to update many WhitelistedUrls.
     * @example
     * // Update many WhitelistedUrls
     * const whitelistedUrl = await prisma.whitelistedUrl.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhitelistedUrls and only return the `id`
     * const whitelistedUrlWithIdOnly = await prisma.whitelistedUrl.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhitelistedUrlUpdateManyAndReturnArgs>(args: SelectSubset<T, WhitelistedUrlUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhitelistedUrl.
     * @param {WhitelistedUrlUpsertArgs} args - Arguments to update or create a WhitelistedUrl.
     * @example
     * // Update or create a WhitelistedUrl
     * const whitelistedUrl = await prisma.whitelistedUrl.upsert({
     *   create: {
     *     // ... data to create a WhitelistedUrl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhitelistedUrl we want to update
     *   }
     * })
     */
    upsert<T extends WhitelistedUrlUpsertArgs>(args: SelectSubset<T, WhitelistedUrlUpsertArgs<ExtArgs>>): Prisma__WhitelistedUrlClient<$Result.GetResult<Prisma.$WhitelistedUrlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhitelistedUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlCountArgs} args - Arguments to filter WhitelistedUrls to count.
     * @example
     * // Count the number of WhitelistedUrls
     * const count = await prisma.whitelistedUrl.count({
     *   where: {
     *     // ... the filter for the WhitelistedUrls we want to count
     *   }
     * })
    **/
    count<T extends WhitelistedUrlCountArgs>(
      args?: Subset<T, WhitelistedUrlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistedUrlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhitelistedUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistedUrlAggregateArgs>(args: Subset<T, WhitelistedUrlAggregateArgs>): Prisma.PrismaPromise<GetWhitelistedUrlAggregateType<T>>

    /**
     * Group by WhitelistedUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistedUrlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistedUrlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistedUrlGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistedUrlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistedUrlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistedUrlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhitelistedUrl model
   */
  readonly fields: WhitelistedUrlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhitelistedUrl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistedUrlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends WhitelistedUrl$createdByArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistedUrl$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends WhitelistedUrl$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, WhitelistedUrl$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhitelistedUrl model
   */
  interface WhitelistedUrlFieldRefs {
    readonly id: FieldRef<"WhitelistedUrl", 'Int'>
    readonly url: FieldRef<"WhitelistedUrl", 'String'>
    readonly domain: FieldRef<"WhitelistedUrl", 'String'>
    readonly createdAt: FieldRef<"WhitelistedUrl", 'DateTime'>
    readonly updatedAt: FieldRef<"WhitelistedUrl", 'DateTime'>
    readonly createdById: FieldRef<"WhitelistedUrl", 'Int'>
    readonly updatedById: FieldRef<"WhitelistedUrl", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * WhitelistedUrl findUnique
   */
  export type WhitelistedUrlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistedUrl to fetch.
     */
    where: WhitelistedUrlWhereUniqueInput
  }

  /**
   * WhitelistedUrl findUniqueOrThrow
   */
  export type WhitelistedUrlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistedUrl to fetch.
     */
    where: WhitelistedUrlWhereUniqueInput
  }

  /**
   * WhitelistedUrl findFirst
   */
  export type WhitelistedUrlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistedUrl to fetch.
     */
    where?: WhitelistedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistedUrls to fetch.
     */
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistedUrls.
     */
    cursor?: WhitelistedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistedUrls.
     */
    distinct?: WhitelistedUrlScalarFieldEnum | WhitelistedUrlScalarFieldEnum[]
  }

  /**
   * WhitelistedUrl findFirstOrThrow
   */
  export type WhitelistedUrlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistedUrl to fetch.
     */
    where?: WhitelistedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistedUrls to fetch.
     */
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhitelistedUrls.
     */
    cursor?: WhitelistedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhitelistedUrls.
     */
    distinct?: WhitelistedUrlScalarFieldEnum | WhitelistedUrlScalarFieldEnum[]
  }

  /**
   * WhitelistedUrl findMany
   */
  export type WhitelistedUrlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter, which WhitelistedUrls to fetch.
     */
    where?: WhitelistedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhitelistedUrls to fetch.
     */
    orderBy?: WhitelistedUrlOrderByWithRelationInput | WhitelistedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhitelistedUrls.
     */
    cursor?: WhitelistedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhitelistedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhitelistedUrls.
     */
    skip?: number
    distinct?: WhitelistedUrlScalarFieldEnum | WhitelistedUrlScalarFieldEnum[]
  }

  /**
   * WhitelistedUrl create
   */
  export type WhitelistedUrlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * The data needed to create a WhitelistedUrl.
     */
    data: XOR<WhitelistedUrlCreateInput, WhitelistedUrlUncheckedCreateInput>
  }

  /**
   * WhitelistedUrl createMany
   */
  export type WhitelistedUrlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhitelistedUrls.
     */
    data: WhitelistedUrlCreateManyInput | WhitelistedUrlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhitelistedUrl createManyAndReturn
   */
  export type WhitelistedUrlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * The data used to create many WhitelistedUrls.
     */
    data: WhitelistedUrlCreateManyInput | WhitelistedUrlCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhitelistedUrl update
   */
  export type WhitelistedUrlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * The data needed to update a WhitelistedUrl.
     */
    data: XOR<WhitelistedUrlUpdateInput, WhitelistedUrlUncheckedUpdateInput>
    /**
     * Choose, which WhitelistedUrl to update.
     */
    where: WhitelistedUrlWhereUniqueInput
  }

  /**
   * WhitelistedUrl updateMany
   */
  export type WhitelistedUrlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhitelistedUrls.
     */
    data: XOR<WhitelistedUrlUpdateManyMutationInput, WhitelistedUrlUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistedUrls to update
     */
    where?: WhitelistedUrlWhereInput
    /**
     * Limit how many WhitelistedUrls to update.
     */
    limit?: number
  }

  /**
   * WhitelistedUrl updateManyAndReturn
   */
  export type WhitelistedUrlUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * The data used to update WhitelistedUrls.
     */
    data: XOR<WhitelistedUrlUpdateManyMutationInput, WhitelistedUrlUncheckedUpdateManyInput>
    /**
     * Filter which WhitelistedUrls to update
     */
    where?: WhitelistedUrlWhereInput
    /**
     * Limit how many WhitelistedUrls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhitelistedUrl upsert
   */
  export type WhitelistedUrlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * The filter to search for the WhitelistedUrl to update in case it exists.
     */
    where: WhitelistedUrlWhereUniqueInput
    /**
     * In case the WhitelistedUrl found by the `where` argument doesn't exist, create a new WhitelistedUrl with this data.
     */
    create: XOR<WhitelistedUrlCreateInput, WhitelistedUrlUncheckedCreateInput>
    /**
     * In case the WhitelistedUrl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistedUrlUpdateInput, WhitelistedUrlUncheckedUpdateInput>
  }

  /**
   * WhitelistedUrl delete
   */
  export type WhitelistedUrlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
    /**
     * Filter which WhitelistedUrl to delete.
     */
    where: WhitelistedUrlWhereUniqueInput
  }

  /**
   * WhitelistedUrl deleteMany
   */
  export type WhitelistedUrlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhitelistedUrls to delete
     */
    where?: WhitelistedUrlWhereInput
    /**
     * Limit how many WhitelistedUrls to delete.
     */
    limit?: number
  }

  /**
   * WhitelistedUrl.createdBy
   */
  export type WhitelistedUrl$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WhitelistedUrl.updatedBy
   */
  export type WhitelistedUrl$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WhitelistedUrl without action
   */
  export type WhitelistedUrlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhitelistedUrl
     */
    select?: WhitelistedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhitelistedUrl
     */
    omit?: WhitelistedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhitelistedUrlInclude<ExtArgs> | null
  }


  /**
   * Model BlockedUrl
   */

  export type AggregateBlockedUrl = {
    _count: BlockedUrlCountAggregateOutputType | null
    _avg: BlockedUrlAvgAggregateOutputType | null
    _sum: BlockedUrlSumAggregateOutputType | null
    _min: BlockedUrlMinAggregateOutputType | null
    _max: BlockedUrlMaxAggregateOutputType | null
  }

  export type BlockedUrlAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type BlockedUrlSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type BlockedUrlMinAggregateOutputType = {
    id: number | null
    url: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type BlockedUrlMaxAggregateOutputType = {
    id: number | null
    url: string | null
    domain: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type BlockedUrlCountAggregateOutputType = {
    id: number
    url: number
    domain: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type BlockedUrlAvgAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type BlockedUrlSumAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type BlockedUrlMinAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type BlockedUrlMaxAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type BlockedUrlCountAggregateInputType = {
    id?: true
    url?: true
    domain?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type BlockedUrlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUrl to aggregate.
     */
    where?: BlockedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUrls to fetch.
     */
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUrls
    **/
    _count?: true | BlockedUrlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockedUrlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockedUrlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUrlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUrlMaxAggregateInputType
  }

  export type GetBlockedUrlAggregateType<T extends BlockedUrlAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUrl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUrl[P]>
      : GetScalarType<T[P], AggregateBlockedUrl[P]>
  }




  export type BlockedUrlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUrlWhereInput
    orderBy?: BlockedUrlOrderByWithAggregationInput | BlockedUrlOrderByWithAggregationInput[]
    by: BlockedUrlScalarFieldEnum[] | BlockedUrlScalarFieldEnum
    having?: BlockedUrlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUrlCountAggregateInputType | true
    _avg?: BlockedUrlAvgAggregateInputType
    _sum?: BlockedUrlSumAggregateInputType
    _min?: BlockedUrlMinAggregateInputType
    _max?: BlockedUrlMaxAggregateInputType
  }

  export type BlockedUrlGroupByOutputType = {
    id: number
    url: string
    domain: string
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: BlockedUrlCountAggregateOutputType | null
    _avg: BlockedUrlAvgAggregateOutputType | null
    _sum: BlockedUrlSumAggregateOutputType | null
    _min: BlockedUrlMinAggregateOutputType | null
    _max: BlockedUrlMaxAggregateOutputType | null
  }

  type GetBlockedUrlGroupByPayload<T extends BlockedUrlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUrlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUrlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUrlGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUrlGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUrlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUrl"]>

  export type BlockedUrlSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUrl"]>

  export type BlockedUrlSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUrl"]>

  export type BlockedUrlSelectScalar = {
    id?: boolean
    url?: boolean
    domain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type BlockedUrlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "domain" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["blockedUrl"]>
  export type BlockedUrlInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }
  export type BlockedUrlIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }
  export type BlockedUrlIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | BlockedUrl$createdByArgs<ExtArgs>
    updatedBy?: boolean | BlockedUrl$updatedByArgs<ExtArgs>
  }

  export type $BlockedUrlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUrl"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      domain: string
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["blockedUrl"]>
    composites: {}
  }

  type BlockedUrlGetPayload<S extends boolean | null | undefined | BlockedUrlDefaultArgs> = $Result.GetResult<Prisma.$BlockedUrlPayload, S>

  type BlockedUrlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockedUrlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockedUrlCountAggregateInputType | true
    }

  export interface BlockedUrlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUrl'], meta: { name: 'BlockedUrl' } }
    /**
     * Find zero or one BlockedUrl that matches the filter.
     * @param {BlockedUrlFindUniqueArgs} args - Arguments to find a BlockedUrl
     * @example
     * // Get one BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUrlFindUniqueArgs>(args: SelectSubset<T, BlockedUrlFindUniqueArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockedUrl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockedUrlFindUniqueOrThrowArgs} args - Arguments to find a BlockedUrl
     * @example
     * // Get one BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUrlFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUrlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUrl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlFindFirstArgs} args - Arguments to find a BlockedUrl
     * @example
     * // Get one BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUrlFindFirstArgs>(args?: SelectSubset<T, BlockedUrlFindFirstArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUrl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlFindFirstOrThrowArgs} args - Arguments to find a BlockedUrl
     * @example
     * // Get one BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUrlFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUrlFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockedUrls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUrls
     * const blockedUrls = await prisma.blockedUrl.findMany()
     * 
     * // Get first 10 BlockedUrls
     * const blockedUrls = await prisma.blockedUrl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockedUrlWithIdOnly = await prisma.blockedUrl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockedUrlFindManyArgs>(args?: SelectSubset<T, BlockedUrlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockedUrl.
     * @param {BlockedUrlCreateArgs} args - Arguments to create a BlockedUrl.
     * @example
     * // Create one BlockedUrl
     * const BlockedUrl = await prisma.blockedUrl.create({
     *   data: {
     *     // ... data to create a BlockedUrl
     *   }
     * })
     * 
     */
    create<T extends BlockedUrlCreateArgs>(args: SelectSubset<T, BlockedUrlCreateArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockedUrls.
     * @param {BlockedUrlCreateManyArgs} args - Arguments to create many BlockedUrls.
     * @example
     * // Create many BlockedUrls
     * const blockedUrl = await prisma.blockedUrl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUrlCreateManyArgs>(args?: SelectSubset<T, BlockedUrlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUrls and returns the data saved in the database.
     * @param {BlockedUrlCreateManyAndReturnArgs} args - Arguments to create many BlockedUrls.
     * @example
     * // Create many BlockedUrls
     * const blockedUrl = await prisma.blockedUrl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUrls and only return the `id`
     * const blockedUrlWithIdOnly = await prisma.blockedUrl.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUrlCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUrlCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockedUrl.
     * @param {BlockedUrlDeleteArgs} args - Arguments to delete one BlockedUrl.
     * @example
     * // Delete one BlockedUrl
     * const BlockedUrl = await prisma.blockedUrl.delete({
     *   where: {
     *     // ... filter to delete one BlockedUrl
     *   }
     * })
     * 
     */
    delete<T extends BlockedUrlDeleteArgs>(args: SelectSubset<T, BlockedUrlDeleteArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockedUrl.
     * @param {BlockedUrlUpdateArgs} args - Arguments to update one BlockedUrl.
     * @example
     * // Update one BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUrlUpdateArgs>(args: SelectSubset<T, BlockedUrlUpdateArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockedUrls.
     * @param {BlockedUrlDeleteManyArgs} args - Arguments to filter BlockedUrls to delete.
     * @example
     * // Delete a few BlockedUrls
     * const { count } = await prisma.blockedUrl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUrlDeleteManyArgs>(args?: SelectSubset<T, BlockedUrlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUrls
     * const blockedUrl = await prisma.blockedUrl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUrlUpdateManyArgs>(args: SelectSubset<T, BlockedUrlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUrls and returns the data updated in the database.
     * @param {BlockedUrlUpdateManyAndReturnArgs} args - Arguments to update many BlockedUrls.
     * @example
     * // Update many BlockedUrls
     * const blockedUrl = await prisma.blockedUrl.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockedUrls and only return the `id`
     * const blockedUrlWithIdOnly = await prisma.blockedUrl.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockedUrlUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockedUrlUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockedUrl.
     * @param {BlockedUrlUpsertArgs} args - Arguments to update or create a BlockedUrl.
     * @example
     * // Update or create a BlockedUrl
     * const blockedUrl = await prisma.blockedUrl.upsert({
     *   create: {
     *     // ... data to create a BlockedUrl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUrl we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUrlUpsertArgs>(args: SelectSubset<T, BlockedUrlUpsertArgs<ExtArgs>>): Prisma__BlockedUrlClient<$Result.GetResult<Prisma.$BlockedUrlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockedUrls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlCountArgs} args - Arguments to filter BlockedUrls to count.
     * @example
     * // Count the number of BlockedUrls
     * const count = await prisma.blockedUrl.count({
     *   where: {
     *     // ... the filter for the BlockedUrls we want to count
     *   }
     * })
    **/
    count<T extends BlockedUrlCountArgs>(
      args?: Subset<T, BlockedUrlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUrlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUrlAggregateArgs>(args: Subset<T, BlockedUrlAggregateArgs>): Prisma.PrismaPromise<GetBlockedUrlAggregateType<T>>

    /**
     * Group by BlockedUrl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUrlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUrlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUrlGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUrlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUrlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUrlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUrl model
   */
  readonly fields: BlockedUrlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUrl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUrlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends BlockedUrl$createdByArgs<ExtArgs> = {}>(args?: Subset<T, BlockedUrl$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    updatedBy<T extends BlockedUrl$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, BlockedUrl$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUrl model
   */
  interface BlockedUrlFieldRefs {
    readonly id: FieldRef<"BlockedUrl", 'Int'>
    readonly url: FieldRef<"BlockedUrl", 'String'>
    readonly domain: FieldRef<"BlockedUrl", 'String'>
    readonly createdAt: FieldRef<"BlockedUrl", 'DateTime'>
    readonly updatedAt: FieldRef<"BlockedUrl", 'DateTime'>
    readonly createdById: FieldRef<"BlockedUrl", 'Int'>
    readonly updatedById: FieldRef<"BlockedUrl", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUrl findUnique
   */
  export type BlockedUrlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUrl to fetch.
     */
    where: BlockedUrlWhereUniqueInput
  }

  /**
   * BlockedUrl findUniqueOrThrow
   */
  export type BlockedUrlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUrl to fetch.
     */
    where: BlockedUrlWhereUniqueInput
  }

  /**
   * BlockedUrl findFirst
   */
  export type BlockedUrlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUrl to fetch.
     */
    where?: BlockedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUrls to fetch.
     */
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUrls.
     */
    cursor?: BlockedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUrls.
     */
    distinct?: BlockedUrlScalarFieldEnum | BlockedUrlScalarFieldEnum[]
  }

  /**
   * BlockedUrl findFirstOrThrow
   */
  export type BlockedUrlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUrl to fetch.
     */
    where?: BlockedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUrls to fetch.
     */
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUrls.
     */
    cursor?: BlockedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUrls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUrls.
     */
    distinct?: BlockedUrlScalarFieldEnum | BlockedUrlScalarFieldEnum[]
  }

  /**
   * BlockedUrl findMany
   */
  export type BlockedUrlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUrls to fetch.
     */
    where?: BlockedUrlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUrls to fetch.
     */
    orderBy?: BlockedUrlOrderByWithRelationInput | BlockedUrlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUrls.
     */
    cursor?: BlockedUrlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUrls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUrls.
     */
    skip?: number
    distinct?: BlockedUrlScalarFieldEnum | BlockedUrlScalarFieldEnum[]
  }

  /**
   * BlockedUrl create
   */
  export type BlockedUrlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedUrl.
     */
    data: XOR<BlockedUrlCreateInput, BlockedUrlUncheckedCreateInput>
  }

  /**
   * BlockedUrl createMany
   */
  export type BlockedUrlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUrls.
     */
    data: BlockedUrlCreateManyInput | BlockedUrlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlockedUrl createManyAndReturn
   */
  export type BlockedUrlCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * The data used to create many BlockedUrls.
     */
    data: BlockedUrlCreateManyInput | BlockedUrlCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUrl update
   */
  export type BlockedUrlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedUrl.
     */
    data: XOR<BlockedUrlUpdateInput, BlockedUrlUncheckedUpdateInput>
    /**
     * Choose, which BlockedUrl to update.
     */
    where: BlockedUrlWhereUniqueInput
  }

  /**
   * BlockedUrl updateMany
   */
  export type BlockedUrlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUrls.
     */
    data: XOR<BlockedUrlUpdateManyMutationInput, BlockedUrlUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUrls to update
     */
    where?: BlockedUrlWhereInput
    /**
     * Limit how many BlockedUrls to update.
     */
    limit?: number
  }

  /**
   * BlockedUrl updateManyAndReturn
   */
  export type BlockedUrlUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * The data used to update BlockedUrls.
     */
    data: XOR<BlockedUrlUpdateManyMutationInput, BlockedUrlUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUrls to update
     */
    where?: BlockedUrlWhereInput
    /**
     * Limit how many BlockedUrls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUrl upsert
   */
  export type BlockedUrlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedUrl to update in case it exists.
     */
    where: BlockedUrlWhereUniqueInput
    /**
     * In case the BlockedUrl found by the `where` argument doesn't exist, create a new BlockedUrl with this data.
     */
    create: XOR<BlockedUrlCreateInput, BlockedUrlUncheckedCreateInput>
    /**
     * In case the BlockedUrl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUrlUpdateInput, BlockedUrlUncheckedUpdateInput>
  }

  /**
   * BlockedUrl delete
   */
  export type BlockedUrlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
    /**
     * Filter which BlockedUrl to delete.
     */
    where: BlockedUrlWhereUniqueInput
  }

  /**
   * BlockedUrl deleteMany
   */
  export type BlockedUrlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUrls to delete
     */
    where?: BlockedUrlWhereInput
    /**
     * Limit how many BlockedUrls to delete.
     */
    limit?: number
  }

  /**
   * BlockedUrl.createdBy
   */
  export type BlockedUrl$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlockedUrl.updatedBy
   */
  export type BlockedUrl$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * BlockedUrl without action
   */
  export type BlockedUrlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUrl
     */
    select?: BlockedUrlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUrl
     */
    omit?: BlockedUrlOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUrlInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
    createdById: number | null
    updatedById: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: number | null
    updatedById: number | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    createdAt: number
    updatedAt: number
    createdById: number
    updatedById: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
    createdById?: true
    updatedById?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    updatedById?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    key: string
    value: string
    type: string
    createdAt: Date
    updatedAt: Date
    createdById: number | null
    updatedById: number | null
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    updatedById?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "type" | "createdAt" | "updatedAt" | "createdById" | "updatedById", ExtArgs["result"]["settings"]>
  export type SettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }
  export type SettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }
  export type SettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    updatedBy?: boolean | Settings$updatedByArgs<ExtArgs>
  }

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string
      value: string
      type: string
      createdAt: Date
      updatedAt: Date
      createdById: number | null
      updatedById: number | null
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    updatedBy<T extends Settings$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Settings$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'String'>
    readonly type: FieldRef<"Settings", 'String'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
    readonly createdById: FieldRef<"Settings", 'Int'>
    readonly updatedById: FieldRef<"Settings", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings.updatedBy
   */
  export type Settings$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    activeStatus: 'activeStatus',
    joiningDate: 'joiningDate',
    fcmToken: 'fcmToken',
    branchId: 'branchId',
    addedById: 'addedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    roleId: 'roleId',
    role: 'role',
    name: 'name'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    permissionId: 'permissionId',
    name: 'name',
    permissionCode: 'permissionCode',
    description: 'description'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const BookScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    publisher: 'publisher',
    userId: 'userId',
    branchId: 'branchId',
    academicYearId: 'academicYearId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    deletedAt: 'deletedAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookScalarFieldEnum = (typeof BookScalarFieldEnum)[keyof typeof BookScalarFieldEnum]


  export const SubjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    userId: 'userId',
    createdById: 'createdById',
    updatedById: 'updatedById',
    deletedAt: 'deletedAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubjectScalarFieldEnum = (typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum]


  export const BookSubjectScalarFieldEnum: {
    id: 'id',
    bookId: 'bookId',
    subjectId: 'subjectId'
  };

  export type BookSubjectScalarFieldEnum = (typeof BookSubjectScalarFieldEnum)[keyof typeof BookSubjectScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    recipientId: 'recipientId',
    senderId: 'senderId',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    subjectId: 'subjectId',
    createdAt: 'createdAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const QRCodeScalarFieldEnum: {
    qrCode: 'qrCode',
    addedById: 'addedById',
    createdById: 'createdById',
    updatedById: 'updatedById',
    qrContent: 'qrContent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QRCodeScalarFieldEnum = (typeof QRCodeScalarFieldEnum)[keyof typeof QRCodeScalarFieldEnum]


  export const RedirectScalarFieldEnum: {
    id: 'id',
    qrCodeId: 'qrCodeId',
    redirect: 'redirect'
  };

  export type RedirectScalarFieldEnum = (typeof RedirectScalarFieldEnum)[keyof typeof RedirectScalarFieldEnum]


  export const AcademicYearScalarFieldEnum: {
    id: 'id',
    label: 'label',
    code: 'code'
  };

  export type AcademicYearScalarFieldEnum = (typeof AcademicYearScalarFieldEnum)[keyof typeof AcademicYearScalarFieldEnum]


  export const BranchScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    createdAt: 'createdAt'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const WhitelistedUrlScalarFieldEnum: {
    id: 'id',
    url: 'url',
    domain: 'domain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type WhitelistedUrlScalarFieldEnum = (typeof WhitelistedUrlScalarFieldEnum)[keyof typeof WhitelistedUrlScalarFieldEnum]


  export const BlockedUrlScalarFieldEnum: {
    id: 'id',
    url: 'url',
    domain: 'domain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type BlockedUrlScalarFieldEnum = (typeof BlockedUrlScalarFieldEnum)[keyof typeof BlockedUrlScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById',
    updatedById: 'updatedById'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    roleId?: IntNullableFilter<"User"> | number | null
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    activeStatus?: BoolFilter<"User"> | boolean
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    fcmToken?: StringNullableFilter<"User"> | string | null
    branchId?: IntNullableFilter<"User"> | number | null
    addedById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: IntNullableFilter<"User"> | number | null
    updatedById?: IntNullableFilter<"User"> | number | null
    role?: XOR<UserRoleNullableScalarRelationFilter, UserRoleWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    createdBooks?: BookListRelationFilter
    updatedBooks?: BookListRelationFilter
    books?: BookListRelationFilter
    createdSubjects?: SubjectListRelationFilter
    updatedSubjects?: SubjectListRelationFilter
    subjects?: SubjectListRelationFilter
    createdQRCodes?: QRCodeListRelationFilter
    updatedQRCodes?: QRCodeListRelationFilter
    addedQRCodes?: QRCodeListRelationFilter
    addedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    addedUsers?: UserListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    updatedSettings?: SettingsListRelationFilter
    addedBlockedUrls?: BlockedUrlListRelationFilter
    updatedBlockedUrls?: BlockedUrlListRelationFilter
    addedWhiteListedUrls?: WhitelistedUrlListRelationFilter
    updatedWhiteListedUrls?: WhitelistedUrlListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    password?: SortOrder
    activeStatus?: SortOrder
    joiningDate?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    role?: UserRoleOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    createdBooks?: BookOrderByRelationAggregateInput
    updatedBooks?: BookOrderByRelationAggregateInput
    books?: BookOrderByRelationAggregateInput
    createdSubjects?: SubjectOrderByRelationAggregateInput
    updatedSubjects?: SubjectOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    createdQRCodes?: QRCodeOrderByRelationAggregateInput
    updatedQRCodes?: QRCodeOrderByRelationAggregateInput
    addedQRCodes?: QRCodeOrderByRelationAggregateInput
    addedBy?: UserOrderByWithRelationInput
    addedUsers?: UserOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentNotifications?: NotificationOrderByRelationAggregateInput
    updatedSettings?: SettingsOrderByRelationAggregateInput
    addedBlockedUrls?: BlockedUrlOrderByRelationAggregateInput
    updatedBlockedUrls?: BlockedUrlOrderByRelationAggregateInput
    addedWhiteListedUrls?: WhitelistedUrlOrderByRelationAggregateInput
    updatedWhiteListedUrls?: WhitelistedUrlOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    roleId?: IntNullableFilter<"User"> | number | null
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    activeStatus?: BoolFilter<"User"> | boolean
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    fcmToken?: StringNullableFilter<"User"> | string | null
    branchId?: IntNullableFilter<"User"> | number | null
    addedById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: IntNullableFilter<"User"> | number | null
    updatedById?: IntNullableFilter<"User"> | number | null
    role?: XOR<UserRoleNullableScalarRelationFilter, UserRoleWhereInput> | null
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    createdBooks?: BookListRelationFilter
    updatedBooks?: BookListRelationFilter
    books?: BookListRelationFilter
    createdSubjects?: SubjectListRelationFilter
    updatedSubjects?: SubjectListRelationFilter
    subjects?: SubjectListRelationFilter
    createdQRCodes?: QRCodeListRelationFilter
    updatedQRCodes?: QRCodeListRelationFilter
    addedQRCodes?: QRCodeListRelationFilter
    addedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    addedUsers?: UserListRelationFilter
    notifications?: NotificationListRelationFilter
    sentNotifications?: NotificationListRelationFilter
    updatedSettings?: SettingsListRelationFilter
    addedBlockedUrls?: BlockedUrlListRelationFilter
    updatedBlockedUrls?: BlockedUrlListRelationFilter
    addedWhiteListedUrls?: WhitelistedUrlListRelationFilter
    updatedWhiteListedUrls?: WhitelistedUrlListRelationFilter
  }, "id" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    password?: SortOrder
    activeStatus?: SortOrder
    joiningDate?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    branchId?: SortOrderInput | SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    roleId?: IntNullableWithAggregatesFilter<"User"> | number | null
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    activeStatus?: BoolWithAggregatesFilter<"User"> | boolean
    joiningDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    fcmToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    branchId?: IntNullableWithAggregatesFilter<"User"> | number | null
    addedById?: IntNullableWithAggregatesFilter<"User"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"User"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"User"> | number | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    roleId?: IntFilter<"UserRole"> | number
    role?: StringFilter<"UserRole"> | string
    name?: StringFilter<"UserRole"> | string
    users?: UserListRelationFilter
    permissions?: PermissionListRelationFilter
  }

  export type UserRoleOrderByWithRelationInput = {
    roleId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
    permissions?: PermissionOrderByRelationAggregateInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    roleId?: number
    role?: string
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    name?: StringFilter<"UserRole"> | string
    users?: UserListRelationFilter
    permissions?: PermissionListRelationFilter
  }, "roleId" | "role">

  export type UserRoleOrderByWithAggregationInput = {
    roleId?: SortOrder
    role?: SortOrder
    name?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    roleId?: IntWithAggregatesFilter<"UserRole"> | number
    role?: StringWithAggregatesFilter<"UserRole"> | string
    name?: StringWithAggregatesFilter<"UserRole"> | string
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    permissionId?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    permissionCode?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    roles?: UserRoleListRelationFilter
  }

  export type PermissionOrderByWithRelationInput = {
    permissionId?: SortOrder
    name?: SortOrder
    permissionCode?: SortOrder
    description?: SortOrderInput | SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    permissionId?: number
    permissionCode?: string
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    name?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
    roles?: UserRoleListRelationFilter
  }, "permissionId" | "permissionCode">

  export type PermissionOrderByWithAggregationInput = {
    permissionId?: SortOrder
    name?: SortOrder
    permissionCode?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    permissionId?: IntWithAggregatesFilter<"Permission"> | number
    name?: StringWithAggregatesFilter<"Permission"> | string
    permissionCode?: StringWithAggregatesFilter<"Permission"> | string
    description?: StringNullableWithAggregatesFilter<"Permission"> | string | null
  }

  export type BookWhereInput = {
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    description?: StringNullableFilter<"Book"> | string | null
    publisher?: StringNullableFilter<"Book"> | string | null
    userId?: IntFilter<"Book"> | number
    branchId?: IntNullableFilter<"Book"> | number | null
    academicYearId?: IntNullableFilter<"Book"> | number | null
    createdById?: IntNullableFilter<"Book"> | number | null
    updatedById?: IntNullableFilter<"Book"> | number | null
    deletedAt?: DateTimeNullableFilter<"Book"> | Date | string | null
    isDeleted?: BoolFilter<"Book"> | boolean
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subjects?: SubjectListRelationFilter
    bookSubjects?: BookSubjectListRelationFilter
  }

  export type BookOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByWithRelationInput
    academicYear?: AcademicYearOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    subjects?: SubjectOrderByRelationAggregateInput
    bookSubjects?: BookSubjectOrderByRelationAggregateInput
  }

  export type BookWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookWhereInput | BookWhereInput[]
    OR?: BookWhereInput[]
    NOT?: BookWhereInput | BookWhereInput[]
    title?: StringFilter<"Book"> | string
    description?: StringNullableFilter<"Book"> | string | null
    publisher?: StringNullableFilter<"Book"> | string | null
    userId?: IntFilter<"Book"> | number
    branchId?: IntNullableFilter<"Book"> | number | null
    academicYearId?: IntNullableFilter<"Book"> | number | null
    createdById?: IntNullableFilter<"Book"> | number | null
    updatedById?: IntNullableFilter<"Book"> | number | null
    deletedAt?: DateTimeNullableFilter<"Book"> | Date | string | null
    isDeleted?: BoolFilter<"Book"> | boolean
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    academicYear?: XOR<AcademicYearNullableScalarRelationFilter, AcademicYearWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    subjects?: SubjectListRelationFilter
    bookSubjects?: BookSubjectListRelationFilter
  }, "id">

  export type BookOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    publisher?: SortOrderInput | SortOrder
    userId?: SortOrder
    branchId?: SortOrderInput | SortOrder
    academicYearId?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookCountOrderByAggregateInput
    _avg?: BookAvgOrderByAggregateInput
    _max?: BookMaxOrderByAggregateInput
    _min?: BookMinOrderByAggregateInput
    _sum?: BookSumOrderByAggregateInput
  }

  export type BookScalarWhereWithAggregatesInput = {
    AND?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    OR?: BookScalarWhereWithAggregatesInput[]
    NOT?: BookScalarWhereWithAggregatesInput | BookScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Book"> | string
    title?: StringWithAggregatesFilter<"Book"> | string
    description?: StringNullableWithAggregatesFilter<"Book"> | string | null
    publisher?: StringNullableWithAggregatesFilter<"Book"> | string | null
    userId?: IntWithAggregatesFilter<"Book"> | number
    branchId?: IntNullableWithAggregatesFilter<"Book"> | number | null
    academicYearId?: IntNullableWithAggregatesFilter<"Book"> | number | null
    createdById?: IntNullableWithAggregatesFilter<"Book"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"Book"> | number | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Book"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Book"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Book"> | Date | string
  }

  export type SubjectWhereInput = {
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    userId?: IntFilter<"Subject"> | number
    createdById?: IntNullableFilter<"Subject"> | number | null
    updatedById?: IntNullableFilter<"Subject"> | number | null
    deletedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: BranchListRelationFilter
    academicYear?: AcademicYearListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    books?: BookListRelationFilter
    bookSubjects?: BookSubjectListRelationFilter
  }

  export type SubjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    branch?: BranchOrderByRelationAggregateInput
    academicYear?: AcademicYearOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    books?: BookOrderByRelationAggregateInput
    bookSubjects?: BookSubjectOrderByRelationAggregateInput
  }

  export type SubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubjectWhereInput | SubjectWhereInput[]
    OR?: SubjectWhereInput[]
    NOT?: SubjectWhereInput | SubjectWhereInput[]
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    userId?: IntFilter<"Subject"> | number
    createdById?: IntNullableFilter<"Subject"> | number | null
    updatedById?: IntNullableFilter<"Subject"> | number | null
    deletedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    branch?: BranchListRelationFilter
    academicYear?: AcademicYearListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    chapters?: ChapterListRelationFilter
    books?: BookListRelationFilter
    bookSubjects?: BookSubjectListRelationFilter
  }, "id">

  export type SubjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubjectCountOrderByAggregateInput
    _avg?: SubjectAvgOrderByAggregateInput
    _max?: SubjectMaxOrderByAggregateInput
    _min?: SubjectMinOrderByAggregateInput
    _sum?: SubjectSumOrderByAggregateInput
  }

  export type SubjectScalarWhereWithAggregatesInput = {
    AND?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    OR?: SubjectScalarWhereWithAggregatesInput[]
    NOT?: SubjectScalarWhereWithAggregatesInput | SubjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subject"> | string
    name?: StringWithAggregatesFilter<"Subject"> | string
    description?: StringNullableWithAggregatesFilter<"Subject"> | string | null
    userId?: IntWithAggregatesFilter<"Subject"> | number
    createdById?: IntNullableWithAggregatesFilter<"Subject"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"Subject"> | number | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Subject"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Subject"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subject"> | Date | string
  }

  export type BookSubjectWhereInput = {
    AND?: BookSubjectWhereInput | BookSubjectWhereInput[]
    OR?: BookSubjectWhereInput[]
    NOT?: BookSubjectWhereInput | BookSubjectWhereInput[]
    id?: IntFilter<"BookSubject"> | number
    bookId?: StringFilter<"BookSubject"> | string
    subjectId?: StringFilter<"BookSubject"> | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type BookSubjectOrderByWithRelationInput = {
    id?: SortOrder
    bookId?: SortOrder
    subjectId?: SortOrder
    book?: BookOrderByWithRelationInput
    subject?: SubjectOrderByWithRelationInput
  }

  export type BookSubjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookId_subjectId?: BookSubjectBookIdSubjectIdCompoundUniqueInput
    AND?: BookSubjectWhereInput | BookSubjectWhereInput[]
    OR?: BookSubjectWhereInput[]
    NOT?: BookSubjectWhereInput | BookSubjectWhereInput[]
    bookId?: StringFilter<"BookSubject"> | string
    subjectId?: StringFilter<"BookSubject"> | string
    book?: XOR<BookScalarRelationFilter, BookWhereInput>
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id" | "bookId_subjectId">

  export type BookSubjectOrderByWithAggregationInput = {
    id?: SortOrder
    bookId?: SortOrder
    subjectId?: SortOrder
    _count?: BookSubjectCountOrderByAggregateInput
    _avg?: BookSubjectAvgOrderByAggregateInput
    _max?: BookSubjectMaxOrderByAggregateInput
    _min?: BookSubjectMinOrderByAggregateInput
    _sum?: BookSubjectSumOrderByAggregateInput
  }

  export type BookSubjectScalarWhereWithAggregatesInput = {
    AND?: BookSubjectScalarWhereWithAggregatesInput | BookSubjectScalarWhereWithAggregatesInput[]
    OR?: BookSubjectScalarWhereWithAggregatesInput[]
    NOT?: BookSubjectScalarWhereWithAggregatesInput | BookSubjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BookSubject"> | number
    bookId?: StringWithAggregatesFilter<"BookSubject"> | string
    subjectId?: StringWithAggregatesFilter<"BookSubject"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: IntFilter<"Notification"> | number
    senderId?: IntNullableFilter<"Notification"> | number | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: IntFilter<"Notification"> | number
    senderId?: IntNullableFilter<"Notification"> | number | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    recipientId?: IntWithAggregatesFilter<"Notification"> | number
    senderId?: IntNullableWithAggregatesFilter<"Notification"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: StringFilter<"Chapter"> | string
    title?: StringFilter<"Chapter"> | string
    content?: StringNullableFilter<"Chapter"> | string | null
    subjectId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    subject?: SubjectOrderByWithRelationInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    title?: StringFilter<"Chapter"> | string
    content?: StringNullableFilter<"Chapter"> | string | null
    subjectId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    subject?: XOR<SubjectScalarRelationFilter, SubjectWhereInput>
  }, "id">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chapter"> | string
    title?: StringWithAggregatesFilter<"Chapter"> | string
    content?: StringNullableWithAggregatesFilter<"Chapter"> | string | null
    subjectId?: StringWithAggregatesFilter<"Chapter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type QRCodeWhereInput = {
    AND?: QRCodeWhereInput | QRCodeWhereInput[]
    OR?: QRCodeWhereInput[]
    NOT?: QRCodeWhereInput | QRCodeWhereInput[]
    qrCode?: StringFilter<"QRCode"> | string
    addedById?: IntFilter<"QRCode"> | number
    createdById?: IntNullableFilter<"QRCode"> | number | null
    updatedById?: IntNullableFilter<"QRCode"> | number | null
    qrContent?: StringFilter<"QRCode"> | string
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
    updatedAt?: DateTimeFilter<"QRCode"> | Date | string
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    redirects?: RedirectListRelationFilter
  }

  export type QRCodeOrderByWithRelationInput = {
    qrCode?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    qrContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addedBy?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
    redirects?: RedirectOrderByRelationAggregateInput
  }

  export type QRCodeWhereUniqueInput = Prisma.AtLeast<{
    qrCode?: string
    AND?: QRCodeWhereInput | QRCodeWhereInput[]
    OR?: QRCodeWhereInput[]
    NOT?: QRCodeWhereInput | QRCodeWhereInput[]
    addedById?: IntFilter<"QRCode"> | number
    createdById?: IntNullableFilter<"QRCode"> | number | null
    updatedById?: IntNullableFilter<"QRCode"> | number | null
    qrContent?: StringFilter<"QRCode"> | string
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
    updatedAt?: DateTimeFilter<"QRCode"> | Date | string
    addedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    redirects?: RedirectListRelationFilter
  }, "qrCode" | "qrCode">

  export type QRCodeOrderByWithAggregationInput = {
    qrCode?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    qrContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QRCodeCountOrderByAggregateInput
    _avg?: QRCodeAvgOrderByAggregateInput
    _max?: QRCodeMaxOrderByAggregateInput
    _min?: QRCodeMinOrderByAggregateInput
    _sum?: QRCodeSumOrderByAggregateInput
  }

  export type QRCodeScalarWhereWithAggregatesInput = {
    AND?: QRCodeScalarWhereWithAggregatesInput | QRCodeScalarWhereWithAggregatesInput[]
    OR?: QRCodeScalarWhereWithAggregatesInput[]
    NOT?: QRCodeScalarWhereWithAggregatesInput | QRCodeScalarWhereWithAggregatesInput[]
    qrCode?: StringWithAggregatesFilter<"QRCode"> | string
    addedById?: IntWithAggregatesFilter<"QRCode"> | number
    createdById?: IntNullableWithAggregatesFilter<"QRCode"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"QRCode"> | number | null
    qrContent?: StringWithAggregatesFilter<"QRCode"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QRCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QRCode"> | Date | string
  }

  export type RedirectWhereInput = {
    AND?: RedirectWhereInput | RedirectWhereInput[]
    OR?: RedirectWhereInput[]
    NOT?: RedirectWhereInput | RedirectWhereInput[]
    id?: IntFilter<"Redirect"> | number
    qrCodeId?: StringFilter<"Redirect"> | string
    redirect?: StringFilter<"Redirect"> | string
    qrCode?: XOR<QRCodeScalarRelationFilter, QRCodeWhereInput>
  }

  export type RedirectOrderByWithRelationInput = {
    id?: SortOrder
    qrCodeId?: SortOrder
    redirect?: SortOrder
    qrCode?: QRCodeOrderByWithRelationInput
  }

  export type RedirectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RedirectWhereInput | RedirectWhereInput[]
    OR?: RedirectWhereInput[]
    NOT?: RedirectWhereInput | RedirectWhereInput[]
    qrCodeId?: StringFilter<"Redirect"> | string
    redirect?: StringFilter<"Redirect"> | string
    qrCode?: XOR<QRCodeScalarRelationFilter, QRCodeWhereInput>
  }, "id">

  export type RedirectOrderByWithAggregationInput = {
    id?: SortOrder
    qrCodeId?: SortOrder
    redirect?: SortOrder
    _count?: RedirectCountOrderByAggregateInput
    _avg?: RedirectAvgOrderByAggregateInput
    _max?: RedirectMaxOrderByAggregateInput
    _min?: RedirectMinOrderByAggregateInput
    _sum?: RedirectSumOrderByAggregateInput
  }

  export type RedirectScalarWhereWithAggregatesInput = {
    AND?: RedirectScalarWhereWithAggregatesInput | RedirectScalarWhereWithAggregatesInput[]
    OR?: RedirectScalarWhereWithAggregatesInput[]
    NOT?: RedirectScalarWhereWithAggregatesInput | RedirectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Redirect"> | number
    qrCodeId?: StringWithAggregatesFilter<"Redirect"> | string
    redirect?: StringWithAggregatesFilter<"Redirect"> | string
  }

  export type AcademicYearWhereInput = {
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    id?: IntFilter<"AcademicYear"> | number
    label?: StringFilter<"AcademicYear"> | string
    code?: StringFilter<"AcademicYear"> | string
    books?: BookListRelationFilter
    subjects?: SubjectListRelationFilter
    branchs?: BranchListRelationFilter
  }

  export type AcademicYearOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    code?: SortOrder
    books?: BookOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
    branchs?: BranchOrderByRelationAggregateInput
  }

  export type AcademicYearWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: AcademicYearWhereInput | AcademicYearWhereInput[]
    OR?: AcademicYearWhereInput[]
    NOT?: AcademicYearWhereInput | AcademicYearWhereInput[]
    label?: StringFilter<"AcademicYear"> | string
    books?: BookListRelationFilter
    subjects?: SubjectListRelationFilter
    branchs?: BranchListRelationFilter
  }, "id" | "code">

  export type AcademicYearOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    code?: SortOrder
    _count?: AcademicYearCountOrderByAggregateInput
    _avg?: AcademicYearAvgOrderByAggregateInput
    _max?: AcademicYearMaxOrderByAggregateInput
    _min?: AcademicYearMinOrderByAggregateInput
    _sum?: AcademicYearSumOrderByAggregateInput
  }

  export type AcademicYearScalarWhereWithAggregatesInput = {
    AND?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    OR?: AcademicYearScalarWhereWithAggregatesInput[]
    NOT?: AcademicYearScalarWhereWithAggregatesInput | AcademicYearScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AcademicYear"> | number
    label?: StringWithAggregatesFilter<"AcademicYear"> | string
    code?: StringWithAggregatesFilter<"AcademicYear"> | string
  }

  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    years?: AcademicYearListRelationFilter
    users?: UserListRelationFilter
    books?: BookListRelationFilter
    subjects?: SubjectListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    years?: AcademicYearOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    books?: BookOrderByRelationAggregateInput
    subjects?: SubjectOrderByRelationAggregateInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    location?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
    years?: AcademicYearListRelationFilter
    users?: UserListRelationFilter
    books?: BookListRelationFilter
    subjects?: SubjectListRelationFilter
  }, "id" | "name">

  export type BranchOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Branch"> | number
    name?: StringWithAggregatesFilter<"Branch"> | string
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type WhitelistedUrlWhereInput = {
    AND?: WhitelistedUrlWhereInput | WhitelistedUrlWhereInput[]
    OR?: WhitelistedUrlWhereInput[]
    NOT?: WhitelistedUrlWhereInput | WhitelistedUrlWhereInput[]
    id?: IntFilter<"WhitelistedUrl"> | number
    url?: StringFilter<"WhitelistedUrl"> | string
    domain?: StringFilter<"WhitelistedUrl"> | string
    createdAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    createdById?: IntNullableFilter<"WhitelistedUrl"> | number | null
    updatedById?: IntNullableFilter<"WhitelistedUrl"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WhitelistedUrlOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type WhitelistedUrlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: WhitelistedUrlWhereInput | WhitelistedUrlWhereInput[]
    OR?: WhitelistedUrlWhereInput[]
    NOT?: WhitelistedUrlWhereInput | WhitelistedUrlWhereInput[]
    domain?: StringFilter<"WhitelistedUrl"> | string
    createdAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    createdById?: IntNullableFilter<"WhitelistedUrl"> | number | null
    updatedById?: IntNullableFilter<"WhitelistedUrl"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "url">

  export type WhitelistedUrlOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: WhitelistedUrlCountOrderByAggregateInput
    _avg?: WhitelistedUrlAvgOrderByAggregateInput
    _max?: WhitelistedUrlMaxOrderByAggregateInput
    _min?: WhitelistedUrlMinOrderByAggregateInput
    _sum?: WhitelistedUrlSumOrderByAggregateInput
  }

  export type WhitelistedUrlScalarWhereWithAggregatesInput = {
    AND?: WhitelistedUrlScalarWhereWithAggregatesInput | WhitelistedUrlScalarWhereWithAggregatesInput[]
    OR?: WhitelistedUrlScalarWhereWithAggregatesInput[]
    NOT?: WhitelistedUrlScalarWhereWithAggregatesInput | WhitelistedUrlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WhitelistedUrl"> | number
    url?: StringWithAggregatesFilter<"WhitelistedUrl"> | string
    domain?: StringWithAggregatesFilter<"WhitelistedUrl"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhitelistedUrl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhitelistedUrl"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"WhitelistedUrl"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"WhitelistedUrl"> | number | null
  }

  export type BlockedUrlWhereInput = {
    AND?: BlockedUrlWhereInput | BlockedUrlWhereInput[]
    OR?: BlockedUrlWhereInput[]
    NOT?: BlockedUrlWhereInput | BlockedUrlWhereInput[]
    id?: IntFilter<"BlockedUrl"> | number
    url?: StringFilter<"BlockedUrl"> | string
    domain?: StringFilter<"BlockedUrl"> | string
    createdAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    createdById?: IntNullableFilter<"BlockedUrl"> | number | null
    updatedById?: IntNullableFilter<"BlockedUrl"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type BlockedUrlOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type BlockedUrlWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    url?: string
    AND?: BlockedUrlWhereInput | BlockedUrlWhereInput[]
    OR?: BlockedUrlWhereInput[]
    NOT?: BlockedUrlWhereInput | BlockedUrlWhereInput[]
    domain?: StringFilter<"BlockedUrl"> | string
    createdAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    createdById?: IntNullableFilter<"BlockedUrl"> | number | null
    updatedById?: IntNullableFilter<"BlockedUrl"> | number | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "url">

  export type BlockedUrlOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: BlockedUrlCountOrderByAggregateInput
    _avg?: BlockedUrlAvgOrderByAggregateInput
    _max?: BlockedUrlMaxOrderByAggregateInput
    _min?: BlockedUrlMinOrderByAggregateInput
    _sum?: BlockedUrlSumOrderByAggregateInput
  }

  export type BlockedUrlScalarWhereWithAggregatesInput = {
    AND?: BlockedUrlScalarWhereWithAggregatesInput | BlockedUrlScalarWhereWithAggregatesInput[]
    OR?: BlockedUrlScalarWhereWithAggregatesInput[]
    NOT?: BlockedUrlScalarWhereWithAggregatesInput | BlockedUrlScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlockedUrl"> | number
    url?: StringWithAggregatesFilter<"BlockedUrl"> | string
    domain?: StringWithAggregatesFilter<"BlockedUrl"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlockedUrl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlockedUrl"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"BlockedUrl"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"BlockedUrl"> | number | null
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
    type?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    createdById?: IntNullableFilter<"Settings"> | number | null
    updatedById?: IntNullableFilter<"Settings"> | number | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    updatedBy?: UserOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    key?: string
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    value?: StringFilter<"Settings"> | string
    type?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    createdById?: IntNullableFilter<"Settings"> | number | null
    updatedById?: IntNullableFilter<"Settings"> | number | null
    updatedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrderInput | SortOrder
    updatedById?: SortOrderInput | SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: StringWithAggregatesFilter<"Settings"> | string
    type?: StringWithAggregatesFilter<"Settings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    createdById?: IntNullableWithAggregatesFilter<"Settings"> | number | null
    updatedById?: IntNullableWithAggregatesFilter<"Settings"> | number | null
  }

  export type UserCreateInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserRoleCreateInput = {
    role: string
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
    permissions?: PermissionCreateNestedManyWithoutRolesInput
  }

  export type UserRoleUncheckedCreateInput = {
    roleId?: number
    role: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput
  }

  export type UserRoleUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUpdateManyWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type UserRoleCreateManyInput = {
    roleId?: number
    role: string
    name: string
  }

  export type UserRoleUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PermissionCreateInput = {
    name: string
    permissionCode: string
    description?: string | null
    roles?: UserRoleCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    permissionId?: number
    name: string
    permissionCode: string
    description?: string | null
    roles?: UserRoleUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type PermissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserRoleUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roles?: UserRoleUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type PermissionCreateManyInput = {
    permissionId?: number
    name: string
    permissionCode: string
    description?: string | null
  }

  export type PermissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BookCreateInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSubjectCreateInput = {
    book: BookCreateNestedOneWithoutBookSubjectsInput
    subject: SubjectCreateNestedOneWithoutBookSubjectsInput
  }

  export type BookSubjectUncheckedCreateInput = {
    id?: number
    bookId: string
    subjectId: string
  }

  export type BookSubjectUpdateInput = {
    book?: BookUpdateOneRequiredWithoutBookSubjectsNestedInput
    subject?: SubjectUpdateOneRequiredWithoutBookSubjectsNestedInput
  }

  export type BookSubjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type BookSubjectCreateManyInput = {
    id?: number
    bookId: string
    subjectId: string
  }

  export type BookSubjectUpdateManyMutationInput = {

  }

  export type BookSubjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: StringFieldUpdateOperationsInput | string
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    recipientId: number
    senderId?: number | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    recipientId: number
    senderId?: number | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
    subject: SubjectCreateNestedOneWithoutChaptersInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: string
    title: string
    content?: string | null
    subjectId: string
    createdAt?: Date | string
  }

  export type ChapterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: SubjectUpdateOneRequiredWithoutChaptersNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManyInput = {
    id?: string
    title: string
    content?: string | null
    subjectId: string
    createdAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subjectId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeCreateInput = {
    qrCode: string
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutAddedQRCodesInput
    createdBy?: UserCreateNestedOneWithoutCreatedQRCodesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedQRCodesInput
    redirects?: RedirectCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateInput = {
    qrCode: string
    addedById: number
    createdById?: number | null
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redirects?: RedirectUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUpdateInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutAddedQRCodesNestedInput
    createdBy?: UserUpdateOneWithoutCreatedQRCodesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedQRCodesNestedInput
    redirects?: RedirectUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redirects?: RedirectUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeCreateManyInput = {
    qrCode: string
    addedById: number
    createdById?: number | null
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QRCodeUpdateManyMutationInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUncheckedUpdateManyInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RedirectCreateInput = {
    redirect: string
    qrCode: QRCodeCreateNestedOneWithoutRedirectsInput
  }

  export type RedirectUncheckedCreateInput = {
    id?: number
    qrCodeId: string
    redirect: string
  }

  export type RedirectUpdateInput = {
    redirect?: StringFieldUpdateOperationsInput | string
    qrCode?: QRCodeUpdateOneRequiredWithoutRedirectsNestedInput
  }

  export type RedirectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    qrCodeId?: StringFieldUpdateOperationsInput | string
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type RedirectCreateManyInput = {
    id?: number
    qrCodeId: string
    redirect: string
  }

  export type RedirectUpdateManyMutationInput = {
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type RedirectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    qrCodeId?: StringFieldUpdateOperationsInput | string
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicYearCreateInput = {
    label: string
    code: string
    books?: BookCreateNestedManyWithoutAcademicYearInput
    subjects?: SubjectCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearUncheckedCreateInput = {
    id?: number
    label: string
    code: string
    books?: BookUncheckedCreateNestedManyWithoutAcademicYearInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchUncheckedCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearUpdateInput = {
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutAcademicYearNestedInput
    subjects?: SubjectUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUpdateManyWithoutYearsNestedInput
  }

  export type AcademicYearUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUncheckedUpdateManyWithoutAcademicYearNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUncheckedUpdateManyWithoutYearsNestedInput
  }

  export type AcademicYearCreateManyInput = {
    id?: number
    label: string
    code: string
  }

  export type AcademicYearUpdateManyMutationInput = {
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type AcademicYearUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type BranchCreateInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearCreateNestedManyWithoutBranchsInput
    users?: UserCreateNestedManyWithoutBranchInput
    books?: BookCreateNestedManyWithoutBranchInput
    subjects?: SubjectCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearUncheckedCreateNestedManyWithoutBranchsInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    books?: BookUncheckedCreateNestedManyWithoutBranchInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUpdateManyWithoutBranchsNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    books?: BookUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUncheckedUpdateManyWithoutBranchsNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    books?: BookUncheckedUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistedUrlCreateInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAddedWhiteListedUrlsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedWhiteListedUrlsInput
  }

  export type WhitelistedUrlUncheckedCreateInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type WhitelistedUrlUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAddedWhiteListedUrlsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedWhiteListedUrlsNestedInput
  }

  export type WhitelistedUrlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhitelistedUrlCreateManyInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type WhitelistedUrlUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhitelistedUrlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlCreateInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAddedBlockedUrlsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBlockedUrlsInput
  }

  export type BlockedUrlUncheckedCreateInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type BlockedUrlUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAddedBlockedUrlsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBlockedUrlsNestedInput
  }

  export type BlockedUrlUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlCreateManyInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type BlockedUrlUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUrlUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsCreateInput = {
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedBy?: UserCreateNestedOneWithoutUpdatedSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type SettingsUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBy?: UserUpdateOneWithoutUpdatedSettingsNestedInput
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsCreateManyInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type SettingsUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleNullableScalarRelationFilter = {
    is?: UserRoleWhereInput | null
    isNot?: UserRoleWhereInput | null
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type BookListRelationFilter = {
    every?: BookWhereInput
    some?: BookWhereInput
    none?: BookWhereInput
  }

  export type SubjectListRelationFilter = {
    every?: SubjectWhereInput
    some?: SubjectWhereInput
    none?: SubjectWhereInput
  }

  export type QRCodeListRelationFilter = {
    every?: QRCodeWhereInput
    some?: QRCodeWhereInput
    none?: QRCodeWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type SettingsListRelationFilter = {
    every?: SettingsWhereInput
    some?: SettingsWhereInput
    none?: SettingsWhereInput
  }

  export type BlockedUrlListRelationFilter = {
    every?: BlockedUrlWhereInput
    some?: BlockedUrlWhereInput
    none?: BlockedUrlWhereInput
  }

  export type WhitelistedUrlListRelationFilter = {
    every?: WhitelistedUrlWhereInput
    some?: WhitelistedUrlWhereInput
    none?: WhitelistedUrlWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BookOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QRCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockedUrlOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhitelistedUrlOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    activeStatus?: SortOrder
    joiningDate?: SortOrder
    fcmToken?: SortOrder
    branchId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    branchId?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    activeStatus?: SortOrder
    joiningDate?: SortOrder
    fcmToken?: SortOrder
    branchId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    activeStatus?: SortOrder
    joiningDate?: SortOrder
    fcmToken?: SortOrder
    branchId?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    branchId?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleCountOrderByAggregateInput = {
    roleId?: SortOrder
    role?: SortOrder
    name?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    roleId?: SortOrder
    role?: SortOrder
    name?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    roleId?: SortOrder
    role?: SortOrder
    name?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    roleId?: SortOrder
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionCountOrderByAggregateInput = {
    permissionId?: SortOrder
    name?: SortOrder
    permissionCode?: SortOrder
    description?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    permissionId?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    permissionId?: SortOrder
    name?: SortOrder
    permissionCode?: SortOrder
    description?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    permissionId?: SortOrder
    name?: SortOrder
    permissionCode?: SortOrder
    description?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    permissionId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AcademicYearNullableScalarRelationFilter = {
    is?: AcademicYearWhereInput | null
    isNot?: AcademicYearWhereInput | null
  }

  export type BookSubjectListRelationFilter = {
    every?: BookSubjectWhereInput
    some?: BookSubjectWhereInput
    none?: BookSubjectWhereInput
  }

  export type BookSubjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publisher?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    academicYearId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookAvgOrderByAggregateInput = {
    userId?: SortOrder
    branchId?: SortOrder
    academicYearId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BookMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publisher?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    academicYearId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    publisher?: SortOrder
    userId?: SortOrder
    branchId?: SortOrder
    academicYearId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookSumOrderByAggregateInput = {
    userId?: SortOrder
    branchId?: SortOrder
    academicYearId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BranchListRelationFilter = {
    every?: BranchWhereInput
    some?: BranchWhereInput
    none?: BranchWhereInput
  }

  export type AcademicYearListRelationFilter = {
    every?: AcademicYearWhereInput
    some?: AcademicYearWhereInput
    none?: AcademicYearWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type BranchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectAvgOrderByAggregateInput = {
    userId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    userId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    deletedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubjectSumOrderByAggregateInput = {
    userId?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BookScalarRelationFilter = {
    is?: BookWhereInput
    isNot?: BookWhereInput
  }

  export type SubjectScalarRelationFilter = {
    is?: SubjectWhereInput
    isNot?: SubjectWhereInput
  }

  export type BookSubjectBookIdSubjectIdCompoundUniqueInput = {
    bookId: string
    subjectId: string
  }

  export type BookSubjectCountOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    subjectId?: SortOrder
  }

  export type BookSubjectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BookSubjectMaxOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    subjectId?: SortOrder
  }

  export type BookSubjectMinOrderByAggregateInput = {
    id?: SortOrder
    bookId?: SortOrder
    subjectId?: SortOrder
  }

  export type BookSubjectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subjectId?: SortOrder
    createdAt?: SortOrder
  }

  export type RedirectListRelationFilter = {
    every?: RedirectWhereInput
    some?: RedirectWhereInput
    none?: RedirectWhereInput
  }

  export type RedirectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QRCodeCountOrderByAggregateInput = {
    qrCode?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    qrContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QRCodeAvgOrderByAggregateInput = {
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type QRCodeMaxOrderByAggregateInput = {
    qrCode?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    qrContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QRCodeMinOrderByAggregateInput = {
    qrCode?: SortOrder
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    qrContent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QRCodeSumOrderByAggregateInput = {
    addedById?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type QRCodeScalarRelationFilter = {
    is?: QRCodeWhereInput
    isNot?: QRCodeWhereInput
  }

  export type RedirectCountOrderByAggregateInput = {
    id?: SortOrder
    qrCodeId?: SortOrder
    redirect?: SortOrder
  }

  export type RedirectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RedirectMaxOrderByAggregateInput = {
    id?: SortOrder
    qrCodeId?: SortOrder
    redirect?: SortOrder
  }

  export type RedirectMinOrderByAggregateInput = {
    id?: SortOrder
    qrCodeId?: SortOrder
    redirect?: SortOrder
  }

  export type RedirectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AcademicYearCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    code?: SortOrder
  }

  export type AcademicYearAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AcademicYearMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    code?: SortOrder
  }

  export type AcademicYearMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    code?: SortOrder
  }

  export type AcademicYearSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WhitelistedUrlCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type WhitelistedUrlAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type WhitelistedUrlMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type WhitelistedUrlMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type WhitelistedUrlSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BlockedUrlCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BlockedUrlAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BlockedUrlMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BlockedUrlMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    domain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type BlockedUrlSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
  }

  export type UserRoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput
    connect?: UserRoleWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutUsersInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    connect?: BranchWhereUniqueInput
  }

  export type BookCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput> | BookCreateWithoutCreatedByInput[] | BookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByInput | BookCreateOrConnectWithoutCreatedByInput[]
    createMany?: BookCreateManyCreatedByInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput> | BookCreateWithoutUpdatedByInput[] | BookUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUpdatedByInput | BookCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BookCreateManyUpdatedByInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutUserInput = {
    create?: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput> | BookCreateWithoutUserInput[] | BookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUserInput | BookCreateOrConnectWithoutUserInput[]
    createMany?: BookCreateManyUserInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput> | SubjectCreateWithoutUpdatedByInput[] | SubjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUpdatedByInput | SubjectCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SubjectCreateManyUpdatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutUserInput = {
    create?: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput> | SubjectCreateWithoutUserInput[] | SubjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUserInput | SubjectCreateOrConnectWithoutUserInput[]
    createMany?: SubjectCreateManyUserInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type QRCodeCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput> | QRCodeCreateWithoutCreatedByInput[] | QRCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutCreatedByInput | QRCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: QRCodeCreateManyCreatedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type QRCodeCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput> | QRCodeCreateWithoutUpdatedByInput[] | QRCodeUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutUpdatedByInput | QRCodeCreateOrConnectWithoutUpdatedByInput[]
    createMany?: QRCodeCreateManyUpdatedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type QRCodeCreateNestedManyWithoutAddedByInput = {
    create?: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput> | QRCodeCreateWithoutAddedByInput[] | QRCodeUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutAddedByInput | QRCodeCreateOrConnectWithoutAddedByInput[]
    createMany?: QRCodeCreateManyAddedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAddedUsersInput = {
    create?: XOR<UserCreateWithoutAddedUsersInput, UserUncheckedCreateWithoutAddedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutAddedByInput = {
    create?: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput> | UserCreateWithoutAddedByInput[] | UserUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddedByInput | UserCreateOrConnectWithoutAddedByInput[]
    createMany?: UserCreateManyAddedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SettingsCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput> | SettingsCreateWithoutUpdatedByInput[] | SettingsUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutUpdatedByInput | SettingsCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SettingsCreateManyUpdatedByInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type BlockedUrlCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput> | BlockedUrlCreateWithoutCreatedByInput[] | BlockedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutCreatedByInput | BlockedUrlCreateOrConnectWithoutCreatedByInput[]
    createMany?: BlockedUrlCreateManyCreatedByInputEnvelope
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
  }

  export type BlockedUrlCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput> | BlockedUrlCreateWithoutUpdatedByInput[] | BlockedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutUpdatedByInput | BlockedUrlCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BlockedUrlCreateManyUpdatedByInputEnvelope
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
  }

  export type WhitelistedUrlCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput> | WhitelistedUrlCreateWithoutCreatedByInput[] | WhitelistedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutCreatedByInput | WhitelistedUrlCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhitelistedUrlCreateManyCreatedByInputEnvelope
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
  }

  export type WhitelistedUrlCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput> | WhitelistedUrlCreateWithoutUpdatedByInput[] | WhitelistedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutUpdatedByInput | WhitelistedUrlCreateOrConnectWithoutUpdatedByInput[]
    createMany?: WhitelistedUrlCreateManyUpdatedByInputEnvelope
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput> | BookCreateWithoutCreatedByInput[] | BookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByInput | BookCreateOrConnectWithoutCreatedByInput[]
    createMany?: BookCreateManyCreatedByInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput> | BookCreateWithoutUpdatedByInput[] | BookUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUpdatedByInput | BookCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BookCreateManyUpdatedByInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput> | BookCreateWithoutUserInput[] | BookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUserInput | BookCreateOrConnectWithoutUserInput[]
    createMany?: BookCreateManyUserInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput> | SubjectCreateWithoutUpdatedByInput[] | SubjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUpdatedByInput | SubjectCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SubjectCreateManyUpdatedByInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput> | SubjectCreateWithoutUserInput[] | SubjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUserInput | SubjectCreateOrConnectWithoutUserInput[]
    createMany?: SubjectCreateManyUserInputEnvelope
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type QRCodeUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput> | QRCodeCreateWithoutCreatedByInput[] | QRCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutCreatedByInput | QRCodeCreateOrConnectWithoutCreatedByInput[]
    createMany?: QRCodeCreateManyCreatedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput> | QRCodeCreateWithoutUpdatedByInput[] | QRCodeUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutUpdatedByInput | QRCodeCreateOrConnectWithoutUpdatedByInput[]
    createMany?: QRCodeCreateManyUpdatedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type QRCodeUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput> | QRCodeCreateWithoutAddedByInput[] | QRCodeUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutAddedByInput | QRCodeCreateOrConnectWithoutAddedByInput[]
    createMany?: QRCodeCreateManyAddedByInputEnvelope
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput> | UserCreateWithoutAddedByInput[] | UserUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddedByInput | UserCreateOrConnectWithoutAddedByInput[]
    createMany?: UserCreateManyAddedByInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type SettingsUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput> | SettingsCreateWithoutUpdatedByInput[] | SettingsUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutUpdatedByInput | SettingsCreateOrConnectWithoutUpdatedByInput[]
    createMany?: SettingsCreateManyUpdatedByInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput> | BlockedUrlCreateWithoutCreatedByInput[] | BlockedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutCreatedByInput | BlockedUrlCreateOrConnectWithoutCreatedByInput[]
    createMany?: BlockedUrlCreateManyCreatedByInputEnvelope
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
  }

  export type BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput> | BlockedUrlCreateWithoutUpdatedByInput[] | BlockedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutUpdatedByInput | BlockedUrlCreateOrConnectWithoutUpdatedByInput[]
    createMany?: BlockedUrlCreateManyUpdatedByInputEnvelope
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
  }

  export type WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput> | WhitelistedUrlCreateWithoutCreatedByInput[] | WhitelistedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutCreatedByInput | WhitelistedUrlCreateOrConnectWithoutCreatedByInput[]
    createMany?: WhitelistedUrlCreateManyCreatedByInputEnvelope
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
  }

  export type WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput> | WhitelistedUrlCreateWithoutUpdatedByInput[] | WhitelistedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutUpdatedByInput | WhitelistedUrlCreateOrConnectWithoutUpdatedByInput[]
    createMany?: WhitelistedUrlCreateManyUpdatedByInputEnvelope
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserRoleUpdateOneWithoutUsersNestedInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput
    upsert?: UserRoleUpsertWithoutUsersInput
    disconnect?: UserRoleWhereInput | boolean
    delete?: UserRoleWhereInput | boolean
    connect?: UserRoleWhereUniqueInput
    update?: XOR<XOR<UserRoleUpdateToOneWithWhereWithoutUsersInput, UserRoleUpdateWithoutUsersInput>, UserRoleUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateOneWithoutUsersNestedInput = {
    create?: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutUsersInput
    upsert?: BranchUpsertWithoutUsersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutUsersInput, BranchUpdateWithoutUsersInput>, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BookUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput> | BookCreateWithoutCreatedByInput[] | BookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByInput | BookCreateOrConnectWithoutCreatedByInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCreatedByInput | BookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BookCreateManyCreatedByInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCreatedByInput | BookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCreatedByInput | BookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput> | BookCreateWithoutUpdatedByInput[] | BookUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUpdatedByInput | BookCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutUpdatedByInput | BookUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BookCreateManyUpdatedByInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutUpdatedByInput | BookUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BookUpdateManyWithWhereWithoutUpdatedByInput | BookUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput> | BookCreateWithoutUserInput[] | BookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUserInput | BookCreateOrConnectWithoutUserInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutUserInput | BookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookCreateManyUserInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutUserInput | BookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookUpdateManyWithWhereWithoutUserInput | BookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCreatedByInput | SubjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCreatedByInput | SubjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCreatedByInput | SubjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput> | SubjectCreateWithoutUpdatedByInput[] | SubjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUpdatedByInput | SubjectCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutUpdatedByInput | SubjectUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SubjectCreateManyUpdatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutUpdatedByInput | SubjectUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutUpdatedByInput | SubjectUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput> | SubjectCreateWithoutUserInput[] | SubjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUserInput | SubjectCreateOrConnectWithoutUserInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutUserInput | SubjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubjectCreateManyUserInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutUserInput | SubjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutUserInput | SubjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type QRCodeUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput> | QRCodeCreateWithoutCreatedByInput[] | QRCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutCreatedByInput | QRCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutCreatedByInput | QRCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QRCodeCreateManyCreatedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutCreatedByInput | QRCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutCreatedByInput | QRCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type QRCodeUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput> | QRCodeCreateWithoutUpdatedByInput[] | QRCodeUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutUpdatedByInput | QRCodeCreateOrConnectWithoutUpdatedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutUpdatedByInput | QRCodeUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: QRCodeCreateManyUpdatedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutUpdatedByInput | QRCodeUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutUpdatedByInput | QRCodeUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type QRCodeUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput> | QRCodeCreateWithoutAddedByInput[] | QRCodeUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutAddedByInput | QRCodeCreateOrConnectWithoutAddedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutAddedByInput | QRCodeUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: QRCodeCreateManyAddedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutAddedByInput | QRCodeUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutAddedByInput | QRCodeUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAddedUsersNestedInput = {
    create?: XOR<UserCreateWithoutAddedUsersInput, UserUncheckedCreateWithoutAddedUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedUsersInput
    upsert?: UserUpsertWithoutAddedUsersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddedUsersInput, UserUpdateWithoutAddedUsersInput>, UserUncheckedUpdateWithoutAddedUsersInput>
  }

  export type UserUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput> | UserCreateWithoutAddedByInput[] | UserUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddedByInput | UserCreateOrConnectWithoutAddedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddedByInput | UserUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: UserCreateManyAddedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddedByInput | UserUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddedByInput | UserUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SettingsUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput> | SettingsCreateWithoutUpdatedByInput[] | SettingsUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutUpdatedByInput | SettingsCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutUpdatedByInput | SettingsUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SettingsCreateManyUpdatedByInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutUpdatedByInput | SettingsUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutUpdatedByInput | SettingsUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type BlockedUrlUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput> | BlockedUrlCreateWithoutCreatedByInput[] | BlockedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutCreatedByInput | BlockedUrlCreateOrConnectWithoutCreatedByInput[]
    upsert?: BlockedUrlUpsertWithWhereUniqueWithoutCreatedByInput | BlockedUrlUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BlockedUrlCreateManyCreatedByInputEnvelope
    set?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    disconnect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    delete?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    update?: BlockedUrlUpdateWithWhereUniqueWithoutCreatedByInput | BlockedUrlUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BlockedUrlUpdateManyWithWhereWithoutCreatedByInput | BlockedUrlUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
  }

  export type BlockedUrlUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput> | BlockedUrlCreateWithoutUpdatedByInput[] | BlockedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutUpdatedByInput | BlockedUrlCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BlockedUrlUpsertWithWhereUniqueWithoutUpdatedByInput | BlockedUrlUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BlockedUrlCreateManyUpdatedByInputEnvelope
    set?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    disconnect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    delete?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    update?: BlockedUrlUpdateWithWhereUniqueWithoutUpdatedByInput | BlockedUrlUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BlockedUrlUpdateManyWithWhereWithoutUpdatedByInput | BlockedUrlUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
  }

  export type WhitelistedUrlUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput> | WhitelistedUrlCreateWithoutCreatedByInput[] | WhitelistedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutCreatedByInput | WhitelistedUrlCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhitelistedUrlUpsertWithWhereUniqueWithoutCreatedByInput | WhitelistedUrlUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhitelistedUrlCreateManyCreatedByInputEnvelope
    set?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    disconnect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    delete?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    update?: WhitelistedUrlUpdateWithWhereUniqueWithoutCreatedByInput | WhitelistedUrlUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhitelistedUrlUpdateManyWithWhereWithoutCreatedByInput | WhitelistedUrlUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
  }

  export type WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput> | WhitelistedUrlCreateWithoutUpdatedByInput[] | WhitelistedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutUpdatedByInput | WhitelistedUrlCreateOrConnectWithoutUpdatedByInput[]
    upsert?: WhitelistedUrlUpsertWithWhereUniqueWithoutUpdatedByInput | WhitelistedUrlUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: WhitelistedUrlCreateManyUpdatedByInputEnvelope
    set?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    disconnect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    delete?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    update?: WhitelistedUrlUpdateWithWhereUniqueWithoutUpdatedByInput | WhitelistedUrlUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: WhitelistedUrlUpdateManyWithWhereWithoutUpdatedByInput | WhitelistedUrlUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput> | BookCreateWithoutCreatedByInput[] | BookUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutCreatedByInput | BookCreateOrConnectWithoutCreatedByInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutCreatedByInput | BookUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BookCreateManyCreatedByInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutCreatedByInput | BookUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BookUpdateManyWithWhereWithoutCreatedByInput | BookUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput> | BookCreateWithoutUpdatedByInput[] | BookUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUpdatedByInput | BookCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutUpdatedByInput | BookUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BookCreateManyUpdatedByInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutUpdatedByInput | BookUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BookUpdateManyWithWhereWithoutUpdatedByInput | BookUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput> | BookCreateWithoutUserInput[] | BookUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookCreateOrConnectWithoutUserInput | BookCreateOrConnectWithoutUserInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutUserInput | BookUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookCreateManyUserInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutUserInput | BookUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookUpdateManyWithWhereWithoutUserInput | BookUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput> | SubjectCreateWithoutCreatedByInput[] | SubjectUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutCreatedByInput | SubjectCreateOrConnectWithoutCreatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutCreatedByInput | SubjectUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SubjectCreateManyCreatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutCreatedByInput | SubjectUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutCreatedByInput | SubjectUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput> | SubjectCreateWithoutUpdatedByInput[] | SubjectUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUpdatedByInput | SubjectCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutUpdatedByInput | SubjectUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SubjectCreateManyUpdatedByInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutUpdatedByInput | SubjectUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutUpdatedByInput | SubjectUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput> | SubjectCreateWithoutUserInput[] | SubjectUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutUserInput | SubjectCreateOrConnectWithoutUserInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutUserInput | SubjectUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubjectCreateManyUserInputEnvelope
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutUserInput | SubjectUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutUserInput | SubjectUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput> | QRCodeCreateWithoutCreatedByInput[] | QRCodeUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutCreatedByInput | QRCodeCreateOrConnectWithoutCreatedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutCreatedByInput | QRCodeUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: QRCodeCreateManyCreatedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutCreatedByInput | QRCodeUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutCreatedByInput | QRCodeUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput> | QRCodeCreateWithoutUpdatedByInput[] | QRCodeUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutUpdatedByInput | QRCodeCreateOrConnectWithoutUpdatedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutUpdatedByInput | QRCodeUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: QRCodeCreateManyUpdatedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutUpdatedByInput | QRCodeUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutUpdatedByInput | QRCodeUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type QRCodeUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput> | QRCodeCreateWithoutAddedByInput[] | QRCodeUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: QRCodeCreateOrConnectWithoutAddedByInput | QRCodeCreateOrConnectWithoutAddedByInput[]
    upsert?: QRCodeUpsertWithWhereUniqueWithoutAddedByInput | QRCodeUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: QRCodeCreateManyAddedByInputEnvelope
    set?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    disconnect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    delete?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    connect?: QRCodeWhereUniqueInput | QRCodeWhereUniqueInput[]
    update?: QRCodeUpdateWithWhereUniqueWithoutAddedByInput | QRCodeUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: QRCodeUpdateManyWithWhereWithoutAddedByInput | QRCodeUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput> | UserCreateWithoutAddedByInput[] | UserUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: UserCreateOrConnectWithoutAddedByInput | UserCreateOrConnectWithoutAddedByInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutAddedByInput | UserUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: UserCreateManyAddedByInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutAddedByInput | UserUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: UserUpdateManyWithWhereWithoutAddedByInput | UserUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput> | SettingsCreateWithoutUpdatedByInput[] | SettingsUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutUpdatedByInput | SettingsCreateOrConnectWithoutUpdatedByInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutUpdatedByInput | SettingsUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: SettingsCreateManyUpdatedByInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutUpdatedByInput | SettingsUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutUpdatedByInput | SettingsUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput> | BlockedUrlCreateWithoutCreatedByInput[] | BlockedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutCreatedByInput | BlockedUrlCreateOrConnectWithoutCreatedByInput[]
    upsert?: BlockedUrlUpsertWithWhereUniqueWithoutCreatedByInput | BlockedUrlUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BlockedUrlCreateManyCreatedByInputEnvelope
    set?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    disconnect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    delete?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    update?: BlockedUrlUpdateWithWhereUniqueWithoutCreatedByInput | BlockedUrlUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BlockedUrlUpdateManyWithWhereWithoutCreatedByInput | BlockedUrlUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
  }

  export type BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput> | BlockedUrlCreateWithoutUpdatedByInput[] | BlockedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: BlockedUrlCreateOrConnectWithoutUpdatedByInput | BlockedUrlCreateOrConnectWithoutUpdatedByInput[]
    upsert?: BlockedUrlUpsertWithWhereUniqueWithoutUpdatedByInput | BlockedUrlUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: BlockedUrlCreateManyUpdatedByInputEnvelope
    set?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    disconnect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    delete?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    connect?: BlockedUrlWhereUniqueInput | BlockedUrlWhereUniqueInput[]
    update?: BlockedUrlUpdateWithWhereUniqueWithoutUpdatedByInput | BlockedUrlUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: BlockedUrlUpdateManyWithWhereWithoutUpdatedByInput | BlockedUrlUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
  }

  export type WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput> | WhitelistedUrlCreateWithoutCreatedByInput[] | WhitelistedUrlUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutCreatedByInput | WhitelistedUrlCreateOrConnectWithoutCreatedByInput[]
    upsert?: WhitelistedUrlUpsertWithWhereUniqueWithoutCreatedByInput | WhitelistedUrlUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: WhitelistedUrlCreateManyCreatedByInputEnvelope
    set?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    disconnect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    delete?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    update?: WhitelistedUrlUpdateWithWhereUniqueWithoutCreatedByInput | WhitelistedUrlUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: WhitelistedUrlUpdateManyWithWhereWithoutCreatedByInput | WhitelistedUrlUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
  }

  export type WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput> | WhitelistedUrlCreateWithoutUpdatedByInput[] | WhitelistedUrlUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: WhitelistedUrlCreateOrConnectWithoutUpdatedByInput | WhitelistedUrlCreateOrConnectWithoutUpdatedByInput[]
    upsert?: WhitelistedUrlUpsertWithWhereUniqueWithoutUpdatedByInput | WhitelistedUrlUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: WhitelistedUrlCreateManyUpdatedByInputEnvelope
    set?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    disconnect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    delete?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    connect?: WhitelistedUrlWhereUniqueInput | WhitelistedUrlWhereUniqueInput[]
    update?: WhitelistedUrlUpdateWithWhereUniqueWithoutUpdatedByInput | WhitelistedUrlUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: WhitelistedUrlUpdateManyWithWhereWithoutUpdatedByInput | WhitelistedUrlUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionCreateNestedManyWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRolesInput | PermissionUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRolesInput | PermissionUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRolesInput | PermissionUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput> | PermissionCreateWithoutRolesInput[] | PermissionUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutRolesInput | PermissionCreateOrConnectWithoutRolesInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutRolesInput | PermissionUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutRolesInput | PermissionUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutRolesInput | PermissionUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput> | UserRoleCreateWithoutPermissionsInput[] | UserRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput | UserRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput> | UserRoleCreateWithoutPermissionsInput[] | UserRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput | UserRoleCreateOrConnectWithoutPermissionsInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput> | UserRoleCreateWithoutPermissionsInput[] | UserRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput | UserRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutPermissionsInput | UserRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutPermissionsInput | UserRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutPermissionsInput | UserRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput> | UserRoleCreateWithoutPermissionsInput[] | UserRoleUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput | UserRoleCreateOrConnectWithoutPermissionsInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutPermissionsInput | UserRoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutPermissionsInput | UserRoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutPermissionsInput | UserRoleUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBooksInput = {
    create?: XOR<UserCreateWithoutBooksInput, UserUncheckedCreateWithoutBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooksInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedOneWithoutBooksInput = {
    create?: XOR<BranchCreateWithoutBooksInput, BranchUncheckedCreateWithoutBooksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBooksInput
    connect?: BranchWhereUniqueInput
  }

  export type AcademicYearCreateNestedOneWithoutBooksInput = {
    create?: XOR<AcademicYearCreateWithoutBooksInput, AcademicYearUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBooksInput
    connect?: AcademicYearWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedBooksInput = {
    create?: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBooksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedBooksInput = {
    create?: XOR<UserCreateWithoutUpdatedBooksInput, UserUncheckedCreateWithoutUpdatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBooksInput
    connect?: UserWhereUniqueInput
  }

  export type SubjectCreateNestedManyWithoutBooksInput = {
    create?: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput> | SubjectCreateWithoutBooksInput[] | SubjectUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBooksInput | SubjectCreateOrConnectWithoutBooksInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BookSubjectCreateNestedManyWithoutBookInput = {
    create?: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput> | BookSubjectCreateWithoutBookInput[] | BookSubjectUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutBookInput | BookSubjectCreateOrConnectWithoutBookInput[]
    createMany?: BookSubjectCreateManyBookInputEnvelope
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutBooksInput = {
    create?: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput> | SubjectCreateWithoutBooksInput[] | SubjectUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBooksInput | SubjectCreateOrConnectWithoutBooksInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BookSubjectUncheckedCreateNestedManyWithoutBookInput = {
    create?: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput> | BookSubjectCreateWithoutBookInput[] | BookSubjectUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutBookInput | BookSubjectCreateOrConnectWithoutBookInput[]
    createMany?: BookSubjectCreateManyBookInputEnvelope
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutBooksNestedInput = {
    create?: XOR<UserCreateWithoutBooksInput, UserUncheckedCreateWithoutBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBooksInput
    upsert?: UserUpsertWithoutBooksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBooksInput, UserUpdateWithoutBooksInput>, UserUncheckedUpdateWithoutBooksInput>
  }

  export type BranchUpdateOneWithoutBooksNestedInput = {
    create?: XOR<BranchCreateWithoutBooksInput, BranchUncheckedCreateWithoutBooksInput>
    connectOrCreate?: BranchCreateOrConnectWithoutBooksInput
    upsert?: BranchUpsertWithoutBooksInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutBooksInput, BranchUpdateWithoutBooksInput>, BranchUncheckedUpdateWithoutBooksInput>
  }

  export type AcademicYearUpdateOneWithoutBooksNestedInput = {
    create?: XOR<AcademicYearCreateWithoutBooksInput, AcademicYearUncheckedCreateWithoutBooksInput>
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBooksInput
    upsert?: AcademicYearUpsertWithoutBooksInput
    disconnect?: AcademicYearWhereInput | boolean
    delete?: AcademicYearWhereInput | boolean
    connect?: AcademicYearWhereUniqueInput
    update?: XOR<XOR<AcademicYearUpdateToOneWithWhereWithoutBooksInput, AcademicYearUpdateWithoutBooksInput>, AcademicYearUncheckedUpdateWithoutBooksInput>
  }

  export type UserUpdateOneWithoutCreatedBooksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedBooksInput
    upsert?: UserUpsertWithoutCreatedBooksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedBooksInput, UserUpdateWithoutCreatedBooksInput>, UserUncheckedUpdateWithoutCreatedBooksInput>
  }

  export type UserUpdateOneWithoutUpdatedBooksNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedBooksInput, UserUncheckedCreateWithoutUpdatedBooksInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBooksInput
    upsert?: UserUpsertWithoutUpdatedBooksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedBooksInput, UserUpdateWithoutUpdatedBooksInput>, UserUncheckedUpdateWithoutUpdatedBooksInput>
  }

  export type SubjectUpdateManyWithoutBooksNestedInput = {
    create?: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput> | SubjectCreateWithoutBooksInput[] | SubjectUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBooksInput | SubjectCreateOrConnectWithoutBooksInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBooksInput | SubjectUpsertWithWhereUniqueWithoutBooksInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBooksInput | SubjectUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBooksInput | SubjectUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BookSubjectUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput> | BookSubjectCreateWithoutBookInput[] | BookSubjectUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutBookInput | BookSubjectCreateOrConnectWithoutBookInput[]
    upsert?: BookSubjectUpsertWithWhereUniqueWithoutBookInput | BookSubjectUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookSubjectCreateManyBookInputEnvelope
    set?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    disconnect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    delete?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    update?: BookSubjectUpdateWithWhereUniqueWithoutBookInput | BookSubjectUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookSubjectUpdateManyWithWhereWithoutBookInput | BookSubjectUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutBooksNestedInput = {
    create?: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput> | SubjectCreateWithoutBooksInput[] | SubjectUncheckedCreateWithoutBooksInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBooksInput | SubjectCreateOrConnectWithoutBooksInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBooksInput | SubjectUpsertWithWhereUniqueWithoutBooksInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBooksInput | SubjectUpdateWithWhereUniqueWithoutBooksInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBooksInput | SubjectUpdateManyWithWhereWithoutBooksInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BookSubjectUncheckedUpdateManyWithoutBookNestedInput = {
    create?: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput> | BookSubjectCreateWithoutBookInput[] | BookSubjectUncheckedCreateWithoutBookInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutBookInput | BookSubjectCreateOrConnectWithoutBookInput[]
    upsert?: BookSubjectUpsertWithWhereUniqueWithoutBookInput | BookSubjectUpsertWithWhereUniqueWithoutBookInput[]
    createMany?: BookSubjectCreateManyBookInputEnvelope
    set?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    disconnect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    delete?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    update?: BookSubjectUpdateWithWhereUniqueWithoutBookInput | BookSubjectUpdateWithWhereUniqueWithoutBookInput[]
    updateMany?: BookSubjectUpdateManyWithWhereWithoutBookInput | BookSubjectUpdateManyWithWhereWithoutBookInput[]
    deleteMany?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSubjectsInput = {
    create?: XOR<UserCreateWithoutSubjectsInput, UserUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type BranchCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput> | BranchCreateWithoutSubjectsInput[] | BranchUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubjectsInput | BranchCreateOrConnectWithoutSubjectsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type AcademicYearCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput> | AcademicYearCreateWithoutSubjectsInput[] | AcademicYearUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSubjectsInput | AcademicYearCreateOrConnectWithoutSubjectsInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedSubjectsInput = {
    create?: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedSubjectsInput = {
    create?: XOR<UserCreateWithoutUpdatedSubjectsInput, UserUncheckedCreateWithoutUpdatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSubjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput> | BookCreateWithoutSubjectsInput[] | BookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSubjectsInput | BookCreateOrConnectWithoutSubjectsInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookSubjectCreateNestedManyWithoutSubjectInput = {
    create?: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput> | BookSubjectCreateWithoutSubjectInput[] | BookSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutSubjectInput | BookSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: BookSubjectCreateManySubjectInputEnvelope
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput> | BranchCreateWithoutSubjectsInput[] | BranchUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubjectsInput | BranchCreateOrConnectWithoutSubjectsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput> | AcademicYearCreateWithoutSubjectsInput[] | AcademicYearUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSubjectsInput | AcademicYearCreateOrConnectWithoutSubjectsInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutSubjectsInput = {
    create?: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput> | BookCreateWithoutSubjectsInput[] | BookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSubjectsInput | BookCreateOrConnectWithoutSubjectsInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type BookSubjectUncheckedCreateNestedManyWithoutSubjectInput = {
    create?: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput> | BookSubjectCreateWithoutSubjectInput[] | BookSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutSubjectInput | BookSubjectCreateOrConnectWithoutSubjectInput[]
    createMany?: BookSubjectCreateManySubjectInputEnvelope
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutSubjectsInput, UserUncheckedCreateWithoutSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubjectsInput
    upsert?: UserUpsertWithoutSubjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubjectsInput, UserUpdateWithoutSubjectsInput>, UserUncheckedUpdateWithoutSubjectsInput>
  }

  export type BranchUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput> | BranchCreateWithoutSubjectsInput[] | BranchUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubjectsInput | BranchCreateOrConnectWithoutSubjectsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutSubjectsInput | BranchUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutSubjectsInput | BranchUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutSubjectsInput | BranchUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type AcademicYearUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput> | AcademicYearCreateWithoutSubjectsInput[] | AcademicYearUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSubjectsInput | AcademicYearCreateOrConnectWithoutSubjectsInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutSubjectsInput | AcademicYearUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutSubjectsInput | AcademicYearUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutSubjectsInput | AcademicYearUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type UserUpdateOneWithoutCreatedSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedSubjectsInput
    upsert?: UserUpsertWithoutCreatedSubjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedSubjectsInput, UserUpdateWithoutCreatedSubjectsInput>, UserUncheckedUpdateWithoutCreatedSubjectsInput>
  }

  export type UserUpdateOneWithoutUpdatedSubjectsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedSubjectsInput, UserUncheckedCreateWithoutUpdatedSubjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSubjectsInput
    upsert?: UserUpsertWithoutUpdatedSubjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedSubjectsInput, UserUpdateWithoutUpdatedSubjectsInput>, UserUncheckedUpdateWithoutUpdatedSubjectsInput>
  }

  export type ChapterUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type BookUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput> | BookCreateWithoutSubjectsInput[] | BookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSubjectsInput | BookCreateOrConnectWithoutSubjectsInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutSubjectsInput | BookUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutSubjectsInput | BookUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BookUpdateManyWithWhereWithoutSubjectsInput | BookUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookSubjectUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput> | BookSubjectCreateWithoutSubjectInput[] | BookSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutSubjectInput | BookSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: BookSubjectUpsertWithWhereUniqueWithoutSubjectInput | BookSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: BookSubjectCreateManySubjectInputEnvelope
    set?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    disconnect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    delete?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    update?: BookSubjectUpdateWithWhereUniqueWithoutSubjectInput | BookSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: BookSubjectUpdateManyWithWhereWithoutSubjectInput | BookSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput> | BranchCreateWithoutSubjectsInput[] | BranchUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutSubjectsInput | BranchCreateOrConnectWithoutSubjectsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutSubjectsInput | BranchUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutSubjectsInput | BranchUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutSubjectsInput | BranchUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput> | AcademicYearCreateWithoutSubjectsInput[] | AcademicYearUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutSubjectsInput | AcademicYearCreateOrConnectWithoutSubjectsInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutSubjectsInput | AcademicYearUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutSubjectsInput | AcademicYearUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutSubjectsInput | AcademicYearUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput> | ChapterCreateWithoutSubjectInput[] | ChapterUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutSubjectInput | ChapterCreateOrConnectWithoutSubjectInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutSubjectInput | ChapterUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: ChapterCreateManySubjectInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutSubjectInput | ChapterUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutSubjectInput | ChapterUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutSubjectsNestedInput = {
    create?: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput> | BookCreateWithoutSubjectsInput[] | BookUncheckedCreateWithoutSubjectsInput[]
    connectOrCreate?: BookCreateOrConnectWithoutSubjectsInput | BookCreateOrConnectWithoutSubjectsInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutSubjectsInput | BookUpsertWithWhereUniqueWithoutSubjectsInput[]
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutSubjectsInput | BookUpdateWithWhereUniqueWithoutSubjectsInput[]
    updateMany?: BookUpdateManyWithWhereWithoutSubjectsInput | BookUpdateManyWithWhereWithoutSubjectsInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput = {
    create?: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput> | BookSubjectCreateWithoutSubjectInput[] | BookSubjectUncheckedCreateWithoutSubjectInput[]
    connectOrCreate?: BookSubjectCreateOrConnectWithoutSubjectInput | BookSubjectCreateOrConnectWithoutSubjectInput[]
    upsert?: BookSubjectUpsertWithWhereUniqueWithoutSubjectInput | BookSubjectUpsertWithWhereUniqueWithoutSubjectInput[]
    createMany?: BookSubjectCreateManySubjectInputEnvelope
    set?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    disconnect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    delete?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    connect?: BookSubjectWhereUniqueInput | BookSubjectWhereUniqueInput[]
    update?: BookSubjectUpdateWithWhereUniqueWithoutSubjectInput | BookSubjectUpdateWithWhereUniqueWithoutSubjectInput[]
    updateMany?: BookSubjectUpdateManyWithWhereWithoutSubjectInput | BookSubjectUpdateManyWithWhereWithoutSubjectInput[]
    deleteMany?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
  }

  export type BookCreateNestedOneWithoutBookSubjectsInput = {
    create?: XOR<BookCreateWithoutBookSubjectsInput, BookUncheckedCreateWithoutBookSubjectsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBookSubjectsInput
    connect?: BookWhereUniqueInput
  }

  export type SubjectCreateNestedOneWithoutBookSubjectsInput = {
    create?: XOR<SubjectCreateWithoutBookSubjectsInput, SubjectUncheckedCreateWithoutBookSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutBookSubjectsInput
    connect?: SubjectWhereUniqueInput
  }

  export type BookUpdateOneRequiredWithoutBookSubjectsNestedInput = {
    create?: XOR<BookCreateWithoutBookSubjectsInput, BookUncheckedCreateWithoutBookSubjectsInput>
    connectOrCreate?: BookCreateOrConnectWithoutBookSubjectsInput
    upsert?: BookUpsertWithoutBookSubjectsInput
    connect?: BookWhereUniqueInput
    update?: XOR<XOR<BookUpdateToOneWithWhereWithoutBookSubjectsInput, BookUpdateWithoutBookSubjectsInput>, BookUncheckedUpdateWithoutBookSubjectsInput>
  }

  export type SubjectUpdateOneRequiredWithoutBookSubjectsNestedInput = {
    create?: XOR<SubjectCreateWithoutBookSubjectsInput, SubjectUncheckedCreateWithoutBookSubjectsInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutBookSubjectsInput
    upsert?: SubjectUpsertWithoutBookSubjectsInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutBookSubjectsInput, SubjectUpdateWithoutBookSubjectsInput>, SubjectUncheckedUpdateWithoutBookSubjectsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentNotificationsInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneWithoutSentNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentNotificationsInput
    upsert?: UserUpsertWithoutSentNotificationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentNotificationsInput, UserUpdateWithoutSentNotificationsInput>, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type SubjectCreateNestedOneWithoutChaptersInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
  }

  export type SubjectUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: SubjectCreateOrConnectWithoutChaptersInput
    upsert?: SubjectUpsertWithoutChaptersInput
    connect?: SubjectWhereUniqueInput
    update?: XOR<XOR<SubjectUpdateToOneWithWhereWithoutChaptersInput, SubjectUpdateWithoutChaptersInput>, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type UserCreateNestedOneWithoutAddedQRCodesInput = {
    create?: XOR<UserCreateWithoutAddedQRCodesInput, UserUncheckedCreateWithoutAddedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedQRCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedQRCodesInput = {
    create?: XOR<UserCreateWithoutCreatedQRCodesInput, UserUncheckedCreateWithoutCreatedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQRCodesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedQRCodesInput = {
    create?: XOR<UserCreateWithoutUpdatedQRCodesInput, UserUncheckedCreateWithoutUpdatedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedQRCodesInput
    connect?: UserWhereUniqueInput
  }

  export type RedirectCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput> | RedirectCreateWithoutQrCodeInput[] | RedirectUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: RedirectCreateOrConnectWithoutQrCodeInput | RedirectCreateOrConnectWithoutQrCodeInput[]
    createMany?: RedirectCreateManyQrCodeInputEnvelope
    connect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
  }

  export type RedirectUncheckedCreateNestedManyWithoutQrCodeInput = {
    create?: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput> | RedirectCreateWithoutQrCodeInput[] | RedirectUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: RedirectCreateOrConnectWithoutQrCodeInput | RedirectCreateOrConnectWithoutQrCodeInput[]
    createMany?: RedirectCreateManyQrCodeInputEnvelope
    connect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAddedQRCodesNestedInput = {
    create?: XOR<UserCreateWithoutAddedQRCodesInput, UserUncheckedCreateWithoutAddedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedQRCodesInput
    upsert?: UserUpsertWithoutAddedQRCodesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddedQRCodesInput, UserUpdateWithoutAddedQRCodesInput>, UserUncheckedUpdateWithoutAddedQRCodesInput>
  }

  export type UserUpdateOneWithoutCreatedQRCodesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedQRCodesInput, UserUncheckedCreateWithoutCreatedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQRCodesInput
    upsert?: UserUpsertWithoutCreatedQRCodesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedQRCodesInput, UserUpdateWithoutCreatedQRCodesInput>, UserUncheckedUpdateWithoutCreatedQRCodesInput>
  }

  export type UserUpdateOneWithoutUpdatedQRCodesNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedQRCodesInput, UserUncheckedCreateWithoutUpdatedQRCodesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedQRCodesInput
    upsert?: UserUpsertWithoutUpdatedQRCodesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedQRCodesInput, UserUpdateWithoutUpdatedQRCodesInput>, UserUncheckedUpdateWithoutUpdatedQRCodesInput>
  }

  export type RedirectUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput> | RedirectCreateWithoutQrCodeInput[] | RedirectUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: RedirectCreateOrConnectWithoutQrCodeInput | RedirectCreateOrConnectWithoutQrCodeInput[]
    upsert?: RedirectUpsertWithWhereUniqueWithoutQrCodeInput | RedirectUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: RedirectCreateManyQrCodeInputEnvelope
    set?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    disconnect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    delete?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    connect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    update?: RedirectUpdateWithWhereUniqueWithoutQrCodeInput | RedirectUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: RedirectUpdateManyWithWhereWithoutQrCodeInput | RedirectUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: RedirectScalarWhereInput | RedirectScalarWhereInput[]
  }

  export type RedirectUncheckedUpdateManyWithoutQrCodeNestedInput = {
    create?: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput> | RedirectCreateWithoutQrCodeInput[] | RedirectUncheckedCreateWithoutQrCodeInput[]
    connectOrCreate?: RedirectCreateOrConnectWithoutQrCodeInput | RedirectCreateOrConnectWithoutQrCodeInput[]
    upsert?: RedirectUpsertWithWhereUniqueWithoutQrCodeInput | RedirectUpsertWithWhereUniqueWithoutQrCodeInput[]
    createMany?: RedirectCreateManyQrCodeInputEnvelope
    set?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    disconnect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    delete?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    connect?: RedirectWhereUniqueInput | RedirectWhereUniqueInput[]
    update?: RedirectUpdateWithWhereUniqueWithoutQrCodeInput | RedirectUpdateWithWhereUniqueWithoutQrCodeInput[]
    updateMany?: RedirectUpdateManyWithWhereWithoutQrCodeInput | RedirectUpdateManyWithWhereWithoutQrCodeInput[]
    deleteMany?: RedirectScalarWhereInput | RedirectScalarWhereInput[]
  }

  export type QRCodeCreateNestedOneWithoutRedirectsInput = {
    create?: XOR<QRCodeCreateWithoutRedirectsInput, QRCodeUncheckedCreateWithoutRedirectsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutRedirectsInput
    connect?: QRCodeWhereUniqueInput
  }

  export type QRCodeUpdateOneRequiredWithoutRedirectsNestedInput = {
    create?: XOR<QRCodeCreateWithoutRedirectsInput, QRCodeUncheckedCreateWithoutRedirectsInput>
    connectOrCreate?: QRCodeCreateOrConnectWithoutRedirectsInput
    upsert?: QRCodeUpsertWithoutRedirectsInput
    connect?: QRCodeWhereUniqueInput
    update?: XOR<XOR<QRCodeUpdateToOneWithWhereWithoutRedirectsInput, QRCodeUpdateWithoutRedirectsInput>, QRCodeUncheckedUpdateWithoutRedirectsInput>
  }

  export type BookCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput> | BookCreateWithoutAcademicYearInput[] | BookUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAcademicYearInput | BookCreateOrConnectWithoutAcademicYearInput[]
    createMany?: BookCreateManyAcademicYearInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput> | SubjectCreateWithoutAcademicYearInput[] | SubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearInput | SubjectCreateOrConnectWithoutAcademicYearInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BranchCreateNestedManyWithoutYearsInput = {
    create?: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput> | BranchCreateWithoutYearsInput[] | BranchUncheckedCreateWithoutYearsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutYearsInput | BranchCreateOrConnectWithoutYearsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput> | BookCreateWithoutAcademicYearInput[] | BookUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAcademicYearInput | BookCreateOrConnectWithoutAcademicYearInput[]
    createMany?: BookCreateManyAcademicYearInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutAcademicYearInput = {
    create?: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput> | SubjectCreateWithoutAcademicYearInput[] | SubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearInput | SubjectCreateOrConnectWithoutAcademicYearInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type BranchUncheckedCreateNestedManyWithoutYearsInput = {
    create?: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput> | BranchCreateWithoutYearsInput[] | BranchUncheckedCreateWithoutYearsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutYearsInput | BranchCreateOrConnectWithoutYearsInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
  }

  export type BookUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput> | BookCreateWithoutAcademicYearInput[] | BookUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAcademicYearInput | BookCreateOrConnectWithoutAcademicYearInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutAcademicYearInput | BookUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: BookCreateManyAcademicYearInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutAcademicYearInput | BookUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: BookUpdateManyWithWhereWithoutAcademicYearInput | BookUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput> | SubjectCreateWithoutAcademicYearInput[] | SubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearInput | SubjectCreateOrConnectWithoutAcademicYearInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutAcademicYearInput | SubjectUpsertWithWhereUniqueWithoutAcademicYearInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutAcademicYearInput | SubjectUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutAcademicYearInput | SubjectUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BranchUpdateManyWithoutYearsNestedInput = {
    create?: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput> | BranchCreateWithoutYearsInput[] | BranchUncheckedCreateWithoutYearsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutYearsInput | BranchCreateOrConnectWithoutYearsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutYearsInput | BranchUpsertWithWhereUniqueWithoutYearsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutYearsInput | BranchUpdateWithWhereUniqueWithoutYearsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutYearsInput | BranchUpdateManyWithWhereWithoutYearsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput> | BookCreateWithoutAcademicYearInput[] | BookUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: BookCreateOrConnectWithoutAcademicYearInput | BookCreateOrConnectWithoutAcademicYearInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutAcademicYearInput | BookUpsertWithWhereUniqueWithoutAcademicYearInput[]
    createMany?: BookCreateManyAcademicYearInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutAcademicYearInput | BookUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: BookUpdateManyWithWhereWithoutAcademicYearInput | BookUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutAcademicYearNestedInput = {
    create?: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput> | SubjectCreateWithoutAcademicYearInput[] | SubjectUncheckedCreateWithoutAcademicYearInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutAcademicYearInput | SubjectCreateOrConnectWithoutAcademicYearInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutAcademicYearInput | SubjectUpsertWithWhereUniqueWithoutAcademicYearInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutAcademicYearInput | SubjectUpdateWithWhereUniqueWithoutAcademicYearInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutAcademicYearInput | SubjectUpdateManyWithWhereWithoutAcademicYearInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type BranchUncheckedUpdateManyWithoutYearsNestedInput = {
    create?: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput> | BranchCreateWithoutYearsInput[] | BranchUncheckedCreateWithoutYearsInput[]
    connectOrCreate?: BranchCreateOrConnectWithoutYearsInput | BranchCreateOrConnectWithoutYearsInput[]
    upsert?: BranchUpsertWithWhereUniqueWithoutYearsInput | BranchUpsertWithWhereUniqueWithoutYearsInput[]
    set?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    disconnect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    delete?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    connect?: BranchWhereUniqueInput | BranchWhereUniqueInput[]
    update?: BranchUpdateWithWhereUniqueWithoutYearsInput | BranchUpdateWithWhereUniqueWithoutYearsInput[]
    updateMany?: BranchUpdateManyWithWhereWithoutYearsInput | BranchUpdateManyWithWhereWithoutYearsInput[]
    deleteMany?: BranchScalarWhereInput | BranchScalarWhereInput[]
  }

  export type AcademicYearCreateNestedManyWithoutBranchsInput = {
    create?: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput> | AcademicYearCreateWithoutBranchsInput[] | AcademicYearUncheckedCreateWithoutBranchsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBranchsInput | AcademicYearCreateOrConnectWithoutBranchsInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput> | BookCreateWithoutBranchInput[] | BookUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookCreateOrConnectWithoutBranchInput | BookCreateOrConnectWithoutBranchInput[]
    createMany?: BookCreateManyBranchInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectCreateNestedManyWithoutBranchInput = {
    create?: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput> | SubjectCreateWithoutBranchInput[] | SubjectUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBranchInput | SubjectCreateOrConnectWithoutBranchInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type AcademicYearUncheckedCreateNestedManyWithoutBranchsInput = {
    create?: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput> | AcademicYearCreateWithoutBranchsInput[] | AcademicYearUncheckedCreateWithoutBranchsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBranchsInput | AcademicYearCreateOrConnectWithoutBranchsInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BookUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput> | BookCreateWithoutBranchInput[] | BookUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookCreateOrConnectWithoutBranchInput | BookCreateOrConnectWithoutBranchInput[]
    createMany?: BookCreateManyBranchInputEnvelope
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
  }

  export type SubjectUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput> | SubjectCreateWithoutBranchInput[] | SubjectUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBranchInput | SubjectCreateOrConnectWithoutBranchInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
  }

  export type AcademicYearUpdateManyWithoutBranchsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput> | AcademicYearCreateWithoutBranchsInput[] | AcademicYearUncheckedCreateWithoutBranchsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBranchsInput | AcademicYearCreateOrConnectWithoutBranchsInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutBranchsInput | AcademicYearUpsertWithWhereUniqueWithoutBranchsInput[]
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutBranchsInput | AcademicYearUpdateWithWhereUniqueWithoutBranchsInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutBranchsInput | AcademicYearUpdateManyWithWhereWithoutBranchsInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type UserUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput> | BookCreateWithoutBranchInput[] | BookUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookCreateOrConnectWithoutBranchInput | BookCreateOrConnectWithoutBranchInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutBranchInput | BookUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookCreateManyBranchInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutBranchInput | BookUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookUpdateManyWithWhereWithoutBranchInput | BookUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput> | SubjectCreateWithoutBranchInput[] | SubjectUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBranchInput | SubjectCreateOrConnectWithoutBranchInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBranchInput | SubjectUpsertWithWhereUniqueWithoutBranchInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBranchInput | SubjectUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBranchInput | SubjectUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type AcademicYearUncheckedUpdateManyWithoutBranchsNestedInput = {
    create?: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput> | AcademicYearCreateWithoutBranchsInput[] | AcademicYearUncheckedCreateWithoutBranchsInput[]
    connectOrCreate?: AcademicYearCreateOrConnectWithoutBranchsInput | AcademicYearCreateOrConnectWithoutBranchsInput[]
    upsert?: AcademicYearUpsertWithWhereUniqueWithoutBranchsInput | AcademicYearUpsertWithWhereUniqueWithoutBranchsInput[]
    set?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    disconnect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    delete?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    connect?: AcademicYearWhereUniqueInput | AcademicYearWhereUniqueInput[]
    update?: AcademicYearUpdateWithWhereUniqueWithoutBranchsInput | AcademicYearUpdateWithWhereUniqueWithoutBranchsInput[]
    updateMany?: AcademicYearUpdateManyWithWhereWithoutBranchsInput | AcademicYearUpdateManyWithWhereWithoutBranchsInput[]
    deleteMany?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput> | UserCreateWithoutBranchInput[] | UserUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: UserCreateOrConnectWithoutBranchInput | UserCreateOrConnectWithoutBranchInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutBranchInput | UserUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: UserCreateManyBranchInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutBranchInput | UserUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: UserUpdateManyWithWhereWithoutBranchInput | UserUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BookUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput> | BookCreateWithoutBranchInput[] | BookUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: BookCreateOrConnectWithoutBranchInput | BookCreateOrConnectWithoutBranchInput[]
    upsert?: BookUpsertWithWhereUniqueWithoutBranchInput | BookUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: BookCreateManyBranchInputEnvelope
    set?: BookWhereUniqueInput | BookWhereUniqueInput[]
    disconnect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    delete?: BookWhereUniqueInput | BookWhereUniqueInput[]
    connect?: BookWhereUniqueInput | BookWhereUniqueInput[]
    update?: BookUpdateWithWhereUniqueWithoutBranchInput | BookUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: BookUpdateManyWithWhereWithoutBranchInput | BookUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: BookScalarWhereInput | BookScalarWhereInput[]
  }

  export type SubjectUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput> | SubjectCreateWithoutBranchInput[] | SubjectUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SubjectCreateOrConnectWithoutBranchInput | SubjectCreateOrConnectWithoutBranchInput[]
    upsert?: SubjectUpsertWithWhereUniqueWithoutBranchInput | SubjectUpsertWithWhereUniqueWithoutBranchInput[]
    set?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    disconnect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    delete?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    connect?: SubjectWhereUniqueInput | SubjectWhereUniqueInput[]
    update?: SubjectUpdateWithWhereUniqueWithoutBranchInput | SubjectUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SubjectUpdateManyWithWhereWithoutBranchInput | SubjectUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddedWhiteListedUrlsInput = {
    create?: XOR<UserCreateWithoutAddedWhiteListedUrlsInput, UserUncheckedCreateWithoutAddedWhiteListedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedWhiteListedUrlsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedWhiteListedUrlsInput = {
    create?: XOR<UserCreateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedCreateWithoutUpdatedWhiteListedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedWhiteListedUrlsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAddedWhiteListedUrlsNestedInput = {
    create?: XOR<UserCreateWithoutAddedWhiteListedUrlsInput, UserUncheckedCreateWithoutAddedWhiteListedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedWhiteListedUrlsInput
    upsert?: UserUpsertWithoutAddedWhiteListedUrlsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddedWhiteListedUrlsInput, UserUpdateWithoutAddedWhiteListedUrlsInput>, UserUncheckedUpdateWithoutAddedWhiteListedUrlsInput>
  }

  export type UserUpdateOneWithoutUpdatedWhiteListedUrlsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedCreateWithoutUpdatedWhiteListedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedWhiteListedUrlsInput
    upsert?: UserUpsertWithoutUpdatedWhiteListedUrlsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedWhiteListedUrlsInput, UserUpdateWithoutUpdatedWhiteListedUrlsInput>, UserUncheckedUpdateWithoutUpdatedWhiteListedUrlsInput>
  }

  export type UserCreateNestedOneWithoutAddedBlockedUrlsInput = {
    create?: XOR<UserCreateWithoutAddedBlockedUrlsInput, UserUncheckedCreateWithoutAddedBlockedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedBlockedUrlsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUpdatedBlockedUrlsInput = {
    create?: XOR<UserCreateWithoutUpdatedBlockedUrlsInput, UserUncheckedCreateWithoutUpdatedBlockedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBlockedUrlsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAddedBlockedUrlsNestedInput = {
    create?: XOR<UserCreateWithoutAddedBlockedUrlsInput, UserUncheckedCreateWithoutAddedBlockedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddedBlockedUrlsInput
    upsert?: UserUpsertWithoutAddedBlockedUrlsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddedBlockedUrlsInput, UserUpdateWithoutAddedBlockedUrlsInput>, UserUncheckedUpdateWithoutAddedBlockedUrlsInput>
  }

  export type UserUpdateOneWithoutUpdatedBlockedUrlsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedBlockedUrlsInput, UserUncheckedCreateWithoutUpdatedBlockedUrlsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedBlockedUrlsInput
    upsert?: UserUpsertWithoutUpdatedBlockedUrlsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedBlockedUrlsInput, UserUpdateWithoutUpdatedBlockedUrlsInput>, UserUncheckedUpdateWithoutUpdatedBlockedUrlsInput>
  }

  export type UserCreateNestedOneWithoutUpdatedSettingsInput = {
    create?: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutUpdatedSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUpdatedSettingsInput
    upsert?: UserUpsertWithoutUpdatedSettingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUpdatedSettingsInput, UserUpdateWithoutUpdatedSettingsInput>, UserUncheckedUpdateWithoutUpdatedSettingsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRoleCreateWithoutUsersInput = {
    role: string
    name: string
    permissions?: PermissionCreateNestedManyWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutUsersInput = {
    roleId?: number
    role: string
    name: string
    permissions?: PermissionUncheckedCreateNestedManyWithoutRolesInput
  }

  export type UserRoleCreateOrConnectWithoutUsersInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
  }

  export type BranchCreateWithoutUsersInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearCreateNestedManyWithoutBranchsInput
    books?: BookCreateNestedManyWithoutBranchInput
    subjects?: SubjectCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearUncheckedCreateNestedManyWithoutBranchsInput
    books?: BookUncheckedCreateNestedManyWithoutBranchInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutUsersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
  }

  export type BookCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutCreatedByInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput>
  }

  export type BookCreateManyCreatedByInputEnvelope = {
    data: BookCreateManyCreatedByInput | BookCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BookCreateWithoutUpdatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutUpdatedByInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput>
  }

  export type BookCreateManyUpdatedByInputEnvelope = {
    data: BookCreateManyUpdatedByInput | BookCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type BookCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutUserInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput>
  }

  export type BookCreateManyUserInputEnvelope = {
    data: BookCreateManyUserInput | BookCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput>
  }

  export type SubjectCreateManyCreatedByInputEnvelope = {
    data: SubjectCreateManyCreatedByInput | SubjectCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutUpdatedByInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput>
  }

  export type SubjectCreateManyUpdatedByInputEnvelope = {
    data: SubjectCreateManyUpdatedByInput | SubjectCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutUserInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput>
  }

  export type SubjectCreateManyUserInputEnvelope = {
    data: SubjectCreateManyUserInput | SubjectCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QRCodeCreateWithoutCreatedByInput = {
    qrCode: string
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutAddedQRCodesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedQRCodesInput
    redirects?: RedirectCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutCreatedByInput = {
    qrCode: string
    addedById: number
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redirects?: RedirectUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutCreatedByInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type QRCodeCreateManyCreatedByInputEnvelope = {
    data: QRCodeCreateManyCreatedByInput | QRCodeCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type QRCodeCreateWithoutUpdatedByInput = {
    qrCode: string
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutAddedQRCodesInput
    createdBy?: UserCreateNestedOneWithoutCreatedQRCodesInput
    redirects?: RedirectCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutUpdatedByInput = {
    qrCode: string
    addedById: number
    createdById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redirects?: RedirectUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutUpdatedByInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput>
  }

  export type QRCodeCreateManyUpdatedByInputEnvelope = {
    data: QRCodeCreateManyUpdatedByInput | QRCodeCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type QRCodeCreateWithoutAddedByInput = {
    qrCode: string
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedQRCodesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedQRCodesInput
    redirects?: RedirectCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeUncheckedCreateWithoutAddedByInput = {
    qrCode: string
    createdById?: number | null
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    redirects?: RedirectUncheckedCreateNestedManyWithoutQrCodeInput
  }

  export type QRCodeCreateOrConnectWithoutAddedByInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput>
  }

  export type QRCodeCreateManyAddedByInputEnvelope = {
    data: QRCodeCreateManyAddedByInput | QRCodeCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAddedUsersInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddedUsersInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedUsersInput, UserUncheckedCreateWithoutAddedUsersInput>
  }

  export type UserCreateWithoutAddedByInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddedByInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput>
  }

  export type UserCreateManyAddedByInputEnvelope = {
    data: UserCreateManyAddedByInput | UserCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    sender?: UserCreateNestedOneWithoutSentNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    senderId?: number | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    title: string
    message: string
    isRead?: boolean
    createdAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    recipientId: number
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type SettingsCreateWithoutUpdatedByInput = {
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type SettingsUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type SettingsCreateOrConnectWithoutUpdatedByInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput>
  }

  export type SettingsCreateManyUpdatedByInputEnvelope = {
    data: SettingsCreateManyUpdatedByInput | SettingsCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUrlCreateWithoutCreatedByInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutUpdatedBlockedUrlsInput
  }

  export type BlockedUrlUncheckedCreateWithoutCreatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: number | null
  }

  export type BlockedUrlCreateOrConnectWithoutCreatedByInput = {
    where: BlockedUrlWhereUniqueInput
    create: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput>
  }

  export type BlockedUrlCreateManyCreatedByInputEnvelope = {
    data: BlockedUrlCreateManyCreatedByInput | BlockedUrlCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BlockedUrlCreateWithoutUpdatedByInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAddedBlockedUrlsInput
  }

  export type BlockedUrlUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type BlockedUrlCreateOrConnectWithoutUpdatedByInput = {
    where: BlockedUrlWhereUniqueInput
    create: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput>
  }

  export type BlockedUrlCreateManyUpdatedByInputEnvelope = {
    data: BlockedUrlCreateManyUpdatedByInput | BlockedUrlCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhitelistedUrlCreateWithoutCreatedByInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutUpdatedWhiteListedUrlsInput
  }

  export type WhitelistedUrlUncheckedCreateWithoutCreatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: number | null
  }

  export type WhitelistedUrlCreateOrConnectWithoutCreatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    create: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput>
  }

  export type WhitelistedUrlCreateManyCreatedByInputEnvelope = {
    data: WhitelistedUrlCreateManyCreatedByInput | WhitelistedUrlCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type WhitelistedUrlCreateWithoutUpdatedByInput = {
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutAddedWhiteListedUrlsInput
  }

  export type WhitelistedUrlUncheckedCreateWithoutUpdatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type WhitelistedUrlCreateOrConnectWithoutUpdatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    create: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput>
  }

  export type WhitelistedUrlCreateManyUpdatedByInputEnvelope = {
    data: WhitelistedUrlCreateManyUpdatedByInput | WhitelistedUrlCreateManyUpdatedByInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithoutUsersInput = {
    update: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
    where?: UserRoleWhereInput
  }

  export type UserRoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: UserRoleWhereInput
    data: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserRoleUpdateWithoutUsersInput = {
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: PermissionUpdateManyWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUsersInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    permissions?: PermissionUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type BranchUpsertWithoutUsersInput = {
    update: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
    create: XOR<BranchCreateWithoutUsersInput, BranchUncheckedCreateWithoutUsersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutUsersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutUsersInput, BranchUncheckedUpdateWithoutUsersInput>
  }

  export type BranchUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUpdateManyWithoutBranchsNestedInput
    books?: BookUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUncheckedUpdateManyWithoutBranchsNestedInput
    books?: BookUncheckedUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BookUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutCreatedByInput, BookUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BookCreateWithoutCreatedByInput, BookUncheckedCreateWithoutCreatedByInput>
  }

  export type BookUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutCreatedByInput, BookUncheckedUpdateWithoutCreatedByInput>
  }

  export type BookUpdateManyWithWhereWithoutCreatedByInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BookScalarWhereInput = {
    AND?: BookScalarWhereInput | BookScalarWhereInput[]
    OR?: BookScalarWhereInput[]
    NOT?: BookScalarWhereInput | BookScalarWhereInput[]
    id?: StringFilter<"Book"> | string
    title?: StringFilter<"Book"> | string
    description?: StringNullableFilter<"Book"> | string | null
    publisher?: StringNullableFilter<"Book"> | string | null
    userId?: IntFilter<"Book"> | number
    branchId?: IntNullableFilter<"Book"> | number | null
    academicYearId?: IntNullableFilter<"Book"> | number | null
    createdById?: IntNullableFilter<"Book"> | number | null
    updatedById?: IntNullableFilter<"Book"> | number | null
    deletedAt?: DateTimeNullableFilter<"Book"> | Date | string | null
    isDeleted?: BoolFilter<"Book"> | boolean
    createdAt?: DateTimeFilter<"Book"> | Date | string
    updatedAt?: DateTimeFilter<"Book"> | Date | string
  }

  export type BookUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutUpdatedByInput, BookUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<BookCreateWithoutUpdatedByInput, BookUncheckedCreateWithoutUpdatedByInput>
  }

  export type BookUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutUpdatedByInput, BookUncheckedUpdateWithoutUpdatedByInput>
  }

  export type BookUpdateManyWithWhereWithoutUpdatedByInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type BookUpsertWithWhereUniqueWithoutUserInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutUserInput, BookUncheckedUpdateWithoutUserInput>
    create: XOR<BookCreateWithoutUserInput, BookUncheckedCreateWithoutUserInput>
  }

  export type BookUpdateWithWhereUniqueWithoutUserInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutUserInput, BookUncheckedUpdateWithoutUserInput>
  }

  export type BookUpdateManyWithWhereWithoutUserInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutUserInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutCreatedByInput, SubjectUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SubjectCreateWithoutCreatedByInput, SubjectUncheckedCreateWithoutCreatedByInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutCreatedByInput, SubjectUncheckedUpdateWithoutCreatedByInput>
  }

  export type SubjectUpdateManyWithWhereWithoutCreatedByInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SubjectScalarWhereInput = {
    AND?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    OR?: SubjectScalarWhereInput[]
    NOT?: SubjectScalarWhereInput | SubjectScalarWhereInput[]
    id?: StringFilter<"Subject"> | string
    name?: StringFilter<"Subject"> | string
    description?: StringNullableFilter<"Subject"> | string | null
    userId?: IntFilter<"Subject"> | number
    createdById?: IntNullableFilter<"Subject"> | number | null
    updatedById?: IntNullableFilter<"Subject"> | number | null
    deletedAt?: DateTimeNullableFilter<"Subject"> | Date | string | null
    isDeleted?: BoolFilter<"Subject"> | boolean
    createdAt?: DateTimeFilter<"Subject"> | Date | string
    updatedAt?: DateTimeFilter<"Subject"> | Date | string
  }

  export type SubjectUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutUpdatedByInput, SubjectUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<SubjectCreateWithoutUpdatedByInput, SubjectUncheckedCreateWithoutUpdatedByInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutUpdatedByInput, SubjectUncheckedUpdateWithoutUpdatedByInput>
  }

  export type SubjectUpdateManyWithWhereWithoutUpdatedByInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutUserInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutUserInput, SubjectUncheckedUpdateWithoutUserInput>
    create: XOR<SubjectCreateWithoutUserInput, SubjectUncheckedCreateWithoutUserInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutUserInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutUserInput, SubjectUncheckedUpdateWithoutUserInput>
  }

  export type SubjectUpdateManyWithWhereWithoutUserInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutUserInput>
  }

  export type QRCodeUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: QRCodeWhereUniqueInput
    update: XOR<QRCodeUpdateWithoutCreatedByInput, QRCodeUncheckedUpdateWithoutCreatedByInput>
    create: XOR<QRCodeCreateWithoutCreatedByInput, QRCodeUncheckedCreateWithoutCreatedByInput>
  }

  export type QRCodeUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: QRCodeWhereUniqueInput
    data: XOR<QRCodeUpdateWithoutCreatedByInput, QRCodeUncheckedUpdateWithoutCreatedByInput>
  }

  export type QRCodeUpdateManyWithWhereWithoutCreatedByInput = {
    where: QRCodeScalarWhereInput
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type QRCodeScalarWhereInput = {
    AND?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
    OR?: QRCodeScalarWhereInput[]
    NOT?: QRCodeScalarWhereInput | QRCodeScalarWhereInput[]
    qrCode?: StringFilter<"QRCode"> | string
    addedById?: IntFilter<"QRCode"> | number
    createdById?: IntNullableFilter<"QRCode"> | number | null
    updatedById?: IntNullableFilter<"QRCode"> | number | null
    qrContent?: StringFilter<"QRCode"> | string
    createdAt?: DateTimeFilter<"QRCode"> | Date | string
    updatedAt?: DateTimeFilter<"QRCode"> | Date | string
  }

  export type QRCodeUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: QRCodeWhereUniqueInput
    update: XOR<QRCodeUpdateWithoutUpdatedByInput, QRCodeUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<QRCodeCreateWithoutUpdatedByInput, QRCodeUncheckedCreateWithoutUpdatedByInput>
  }

  export type QRCodeUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: QRCodeWhereUniqueInput
    data: XOR<QRCodeUpdateWithoutUpdatedByInput, QRCodeUncheckedUpdateWithoutUpdatedByInput>
  }

  export type QRCodeUpdateManyWithWhereWithoutUpdatedByInput = {
    where: QRCodeScalarWhereInput
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type QRCodeUpsertWithWhereUniqueWithoutAddedByInput = {
    where: QRCodeWhereUniqueInput
    update: XOR<QRCodeUpdateWithoutAddedByInput, QRCodeUncheckedUpdateWithoutAddedByInput>
    create: XOR<QRCodeCreateWithoutAddedByInput, QRCodeUncheckedCreateWithoutAddedByInput>
  }

  export type QRCodeUpdateWithWhereUniqueWithoutAddedByInput = {
    where: QRCodeWhereUniqueInput
    data: XOR<QRCodeUpdateWithoutAddedByInput, QRCodeUncheckedUpdateWithoutAddedByInput>
  }

  export type QRCodeUpdateManyWithWhereWithoutAddedByInput = {
    where: QRCodeScalarWhereInput
    data: XOR<QRCodeUpdateManyMutationInput, QRCodeUncheckedUpdateManyWithoutAddedByInput>
  }

  export type UserUpsertWithoutAddedUsersInput = {
    update: XOR<UserUpdateWithoutAddedUsersInput, UserUncheckedUpdateWithoutAddedUsersInput>
    create: XOR<UserCreateWithoutAddedUsersInput, UserUncheckedCreateWithoutAddedUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddedUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddedUsersInput, UserUncheckedUpdateWithoutAddedUsersInput>
  }

  export type UserUpdateWithoutAddedUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutAddedByInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutAddedByInput, UserUncheckedUpdateWithoutAddedByInput>
    create: XOR<UserCreateWithoutAddedByInput, UserUncheckedCreateWithoutAddedByInput>
  }

  export type UserUpdateWithWhereUniqueWithoutAddedByInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutAddedByInput, UserUncheckedUpdateWithoutAddedByInput>
  }

  export type UserUpdateManyWithWhereWithoutAddedByInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutAddedByInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    roleId?: IntNullableFilter<"User"> | number | null
    name?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    activeStatus?: BoolFilter<"User"> | boolean
    joiningDate?: DateTimeNullableFilter<"User"> | Date | string | null
    fcmToken?: StringNullableFilter<"User"> | string | null
    branchId?: IntNullableFilter<"User"> | number | null
    addedById?: IntNullableFilter<"User"> | number | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdById?: IntNullableFilter<"User"> | number | null
    updatedById?: IntNullableFilter<"User"> | number | null
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    recipientId?: IntFilter<"Notification"> | number
    senderId?: IntNullableFilter<"Notification"> | number | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type SettingsUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: SettingsWhereUniqueInput
    update: XOR<SettingsUpdateWithoutUpdatedByInput, SettingsUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<SettingsCreateWithoutUpdatedByInput, SettingsUncheckedCreateWithoutUpdatedByInput>
  }

  export type SettingsUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: SettingsWhereUniqueInput
    data: XOR<SettingsUpdateWithoutUpdatedByInput, SettingsUncheckedUpdateWithoutUpdatedByInput>
  }

  export type SettingsUpdateManyWithWhereWithoutUpdatedByInput = {
    where: SettingsScalarWhereInput
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type SettingsScalarWhereInput = {
    AND?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    OR?: SettingsScalarWhereInput[]
    NOT?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    id?: IntFilter<"Settings"> | number
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
    type?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    createdById?: IntNullableFilter<"Settings"> | number | null
    updatedById?: IntNullableFilter<"Settings"> | number | null
  }

  export type BlockedUrlUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BlockedUrlWhereUniqueInput
    update: XOR<BlockedUrlUpdateWithoutCreatedByInput, BlockedUrlUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BlockedUrlCreateWithoutCreatedByInput, BlockedUrlUncheckedCreateWithoutCreatedByInput>
  }

  export type BlockedUrlUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BlockedUrlWhereUniqueInput
    data: XOR<BlockedUrlUpdateWithoutCreatedByInput, BlockedUrlUncheckedUpdateWithoutCreatedByInput>
  }

  export type BlockedUrlUpdateManyWithWhereWithoutCreatedByInput = {
    where: BlockedUrlScalarWhereInput
    data: XOR<BlockedUrlUpdateManyMutationInput, BlockedUrlUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BlockedUrlScalarWhereInput = {
    AND?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
    OR?: BlockedUrlScalarWhereInput[]
    NOT?: BlockedUrlScalarWhereInput | BlockedUrlScalarWhereInput[]
    id?: IntFilter<"BlockedUrl"> | number
    url?: StringFilter<"BlockedUrl"> | string
    domain?: StringFilter<"BlockedUrl"> | string
    createdAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"BlockedUrl"> | Date | string
    createdById?: IntNullableFilter<"BlockedUrl"> | number | null
    updatedById?: IntNullableFilter<"BlockedUrl"> | number | null
  }

  export type BlockedUrlUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: BlockedUrlWhereUniqueInput
    update: XOR<BlockedUrlUpdateWithoutUpdatedByInput, BlockedUrlUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<BlockedUrlCreateWithoutUpdatedByInput, BlockedUrlUncheckedCreateWithoutUpdatedByInput>
  }

  export type BlockedUrlUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: BlockedUrlWhereUniqueInput
    data: XOR<BlockedUrlUpdateWithoutUpdatedByInput, BlockedUrlUncheckedUpdateWithoutUpdatedByInput>
  }

  export type BlockedUrlUpdateManyWithWhereWithoutUpdatedByInput = {
    where: BlockedUrlScalarWhereInput
    data: XOR<BlockedUrlUpdateManyMutationInput, BlockedUrlUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type WhitelistedUrlUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    update: XOR<WhitelistedUrlUpdateWithoutCreatedByInput, WhitelistedUrlUncheckedUpdateWithoutCreatedByInput>
    create: XOR<WhitelistedUrlCreateWithoutCreatedByInput, WhitelistedUrlUncheckedCreateWithoutCreatedByInput>
  }

  export type WhitelistedUrlUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    data: XOR<WhitelistedUrlUpdateWithoutCreatedByInput, WhitelistedUrlUncheckedUpdateWithoutCreatedByInput>
  }

  export type WhitelistedUrlUpdateManyWithWhereWithoutCreatedByInput = {
    where: WhitelistedUrlScalarWhereInput
    data: XOR<WhitelistedUrlUpdateManyMutationInput, WhitelistedUrlUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type WhitelistedUrlScalarWhereInput = {
    AND?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
    OR?: WhitelistedUrlScalarWhereInput[]
    NOT?: WhitelistedUrlScalarWhereInput | WhitelistedUrlScalarWhereInput[]
    id?: IntFilter<"WhitelistedUrl"> | number
    url?: StringFilter<"WhitelistedUrl"> | string
    domain?: StringFilter<"WhitelistedUrl"> | string
    createdAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    updatedAt?: DateTimeFilter<"WhitelistedUrl"> | Date | string
    createdById?: IntNullableFilter<"WhitelistedUrl"> | number | null
    updatedById?: IntNullableFilter<"WhitelistedUrl"> | number | null
  }

  export type WhitelistedUrlUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    update: XOR<WhitelistedUrlUpdateWithoutUpdatedByInput, WhitelistedUrlUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<WhitelistedUrlCreateWithoutUpdatedByInput, WhitelistedUrlUncheckedCreateWithoutUpdatedByInput>
  }

  export type WhitelistedUrlUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: WhitelistedUrlWhereUniqueInput
    data: XOR<WhitelistedUrlUpdateWithoutUpdatedByInput, WhitelistedUrlUncheckedUpdateWithoutUpdatedByInput>
  }

  export type WhitelistedUrlUpdateManyWithWhereWithoutUpdatedByInput = {
    where: WhitelistedUrlScalarWhereInput
    data: XOR<WhitelistedUrlUpdateManyMutationInput, WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type UserCreateWithoutRoleInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: number
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type PermissionCreateWithoutRolesInput = {
    name: string
    permissionCode: string
    description?: string | null
  }

  export type PermissionUncheckedCreateWithoutRolesInput = {
    permissionId?: number
    name: string
    permissionCode: string
    description?: string | null
  }

  export type PermissionCreateOrConnectWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type PermissionUpsertWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
    create: XOR<PermissionCreateWithoutRolesInput, PermissionUncheckedCreateWithoutRolesInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutRolesInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutRolesInput, PermissionUncheckedUpdateWithoutRolesInput>
  }

  export type PermissionUpdateManyWithWhereWithoutRolesInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutRolesInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    permissionId?: IntFilter<"Permission"> | number
    name?: StringFilter<"Permission"> | string
    permissionCode?: StringFilter<"Permission"> | string
    description?: StringNullableFilter<"Permission"> | string | null
  }

  export type UserRoleCreateWithoutPermissionsInput = {
    role: string
    name: string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type UserRoleUncheckedCreateWithoutPermissionsInput = {
    roleId?: number
    role: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type UserRoleCreateOrConnectWithoutPermissionsInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutPermissionsInput, UserRoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutPermissionsInput, UserRoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutPermissionsInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    roleId?: IntFilter<"UserRole"> | number
    role?: StringFilter<"UserRole"> | string
    name?: StringFilter<"UserRole"> | string
  }

  export type UserCreateWithoutBooksInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutBooksInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutBooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBooksInput, UserUncheckedCreateWithoutBooksInput>
  }

  export type BranchCreateWithoutBooksInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearCreateNestedManyWithoutBranchsInput
    users?: UserCreateNestedManyWithoutBranchInput
    subjects?: SubjectCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutBooksInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearUncheckedCreateNestedManyWithoutBranchsInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutBooksInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutBooksInput, BranchUncheckedCreateWithoutBooksInput>
  }

  export type AcademicYearCreateWithoutBooksInput = {
    label: string
    code: string
    subjects?: SubjectCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearUncheckedCreateWithoutBooksInput = {
    id?: number
    label: string
    code: string
    subjects?: SubjectUncheckedCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchUncheckedCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearCreateOrConnectWithoutBooksInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutBooksInput, AcademicYearUncheckedCreateWithoutBooksInput>
  }

  export type UserCreateWithoutCreatedBooksInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedBooksInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedBooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
  }

  export type UserCreateWithoutUpdatedBooksInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedBooksInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedBooksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedBooksInput, UserUncheckedCreateWithoutUpdatedBooksInput>
  }

  export type SubjectCreateWithoutBooksInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutBooksInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutBooksInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput>
  }

  export type BookSubjectCreateWithoutBookInput = {
    subject: SubjectCreateNestedOneWithoutBookSubjectsInput
  }

  export type BookSubjectUncheckedCreateWithoutBookInput = {
    id?: number
    subjectId: string
  }

  export type BookSubjectCreateOrConnectWithoutBookInput = {
    where: BookSubjectWhereUniqueInput
    create: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput>
  }

  export type BookSubjectCreateManyBookInputEnvelope = {
    data: BookSubjectCreateManyBookInput | BookSubjectCreateManyBookInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBooksInput = {
    update: XOR<UserUpdateWithoutBooksInput, UserUncheckedUpdateWithoutBooksInput>
    create: XOR<UserCreateWithoutBooksInput, UserUncheckedCreateWithoutBooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBooksInput, UserUncheckedUpdateWithoutBooksInput>
  }

  export type UserUpdateWithoutBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithoutBooksInput = {
    update: XOR<BranchUpdateWithoutBooksInput, BranchUncheckedUpdateWithoutBooksInput>
    create: XOR<BranchCreateWithoutBooksInput, BranchUncheckedCreateWithoutBooksInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutBooksInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutBooksInput, BranchUncheckedUpdateWithoutBooksInput>
  }

  export type BranchUpdateWithoutBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUpdateManyWithoutBranchsNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUncheckedUpdateManyWithoutBranchsNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type AcademicYearUpsertWithoutBooksInput = {
    update: XOR<AcademicYearUpdateWithoutBooksInput, AcademicYearUncheckedUpdateWithoutBooksInput>
    create: XOR<AcademicYearCreateWithoutBooksInput, AcademicYearUncheckedCreateWithoutBooksInput>
    where?: AcademicYearWhereInput
  }

  export type AcademicYearUpdateToOneWithWhereWithoutBooksInput = {
    where?: AcademicYearWhereInput
    data: XOR<AcademicYearUpdateWithoutBooksInput, AcademicYearUncheckedUpdateWithoutBooksInput>
  }

  export type AcademicYearUpdateWithoutBooksInput = {
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subjects?: SubjectUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUpdateManyWithoutYearsNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    subjects?: SubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUncheckedUpdateManyWithoutYearsNestedInput
  }

  export type UserUpsertWithoutCreatedBooksInput = {
    update: XOR<UserUpdateWithoutCreatedBooksInput, UserUncheckedUpdateWithoutCreatedBooksInput>
    create: XOR<UserCreateWithoutCreatedBooksInput, UserUncheckedCreateWithoutCreatedBooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedBooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedBooksInput, UserUncheckedUpdateWithoutCreatedBooksInput>
  }

  export type UserUpdateWithoutCreatedBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedBooksInput = {
    update: XOR<UserUpdateWithoutUpdatedBooksInput, UserUncheckedUpdateWithoutUpdatedBooksInput>
    create: XOR<UserCreateWithoutUpdatedBooksInput, UserUncheckedCreateWithoutUpdatedBooksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedBooksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedBooksInput, UserUncheckedUpdateWithoutUpdatedBooksInput>
  }

  export type UserUpdateWithoutUpdatedBooksInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedBooksInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SubjectUpsertWithWhereUniqueWithoutBooksInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutBooksInput, SubjectUncheckedUpdateWithoutBooksInput>
    create: XOR<SubjectCreateWithoutBooksInput, SubjectUncheckedCreateWithoutBooksInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutBooksInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutBooksInput, SubjectUncheckedUpdateWithoutBooksInput>
  }

  export type SubjectUpdateManyWithWhereWithoutBooksInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutBooksInput>
  }

  export type BookSubjectUpsertWithWhereUniqueWithoutBookInput = {
    where: BookSubjectWhereUniqueInput
    update: XOR<BookSubjectUpdateWithoutBookInput, BookSubjectUncheckedUpdateWithoutBookInput>
    create: XOR<BookSubjectCreateWithoutBookInput, BookSubjectUncheckedCreateWithoutBookInput>
  }

  export type BookSubjectUpdateWithWhereUniqueWithoutBookInput = {
    where: BookSubjectWhereUniqueInput
    data: XOR<BookSubjectUpdateWithoutBookInput, BookSubjectUncheckedUpdateWithoutBookInput>
  }

  export type BookSubjectUpdateManyWithWhereWithoutBookInput = {
    where: BookSubjectScalarWhereInput
    data: XOR<BookSubjectUpdateManyMutationInput, BookSubjectUncheckedUpdateManyWithoutBookInput>
  }

  export type BookSubjectScalarWhereInput = {
    AND?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
    OR?: BookSubjectScalarWhereInput[]
    NOT?: BookSubjectScalarWhereInput | BookSubjectScalarWhereInput[]
    id?: IntFilter<"BookSubject"> | number
    bookId?: StringFilter<"BookSubject"> | string
    subjectId?: StringFilter<"BookSubject"> | string
  }

  export type UserCreateWithoutSubjectsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSubjectsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubjectsInput, UserUncheckedCreateWithoutSubjectsInput>
  }

  export type BranchCreateWithoutSubjectsInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearCreateNestedManyWithoutBranchsInput
    users?: UserCreateNestedManyWithoutBranchInput
    books?: BookCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSubjectsInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    years?: AcademicYearUncheckedCreateNestedManyWithoutBranchsInput
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    books?: BookUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSubjectsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput>
  }

  export type AcademicYearCreateWithoutSubjectsInput = {
    label: string
    code: string
    books?: BookCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearUncheckedCreateWithoutSubjectsInput = {
    id?: number
    label: string
    code: string
    books?: BookUncheckedCreateNestedManyWithoutAcademicYearInput
    branchs?: BranchUncheckedCreateNestedManyWithoutYearsInput
  }

  export type AcademicYearCreateOrConnectWithoutSubjectsInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput>
  }

  export type UserCreateWithoutCreatedSubjectsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedSubjectsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
  }

  export type UserCreateWithoutUpdatedSubjectsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedSubjectsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedSubjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedSubjectsInput, UserUncheckedCreateWithoutUpdatedSubjectsInput>
  }

  export type ChapterCreateWithoutSubjectInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type ChapterUncheckedCreateWithoutSubjectInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type ChapterCreateOrConnectWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterCreateManySubjectInputEnvelope = {
    data: ChapterCreateManySubjectInput | ChapterCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type BookCreateWithoutSubjectsInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutSubjectsInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutSubjectsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput>
  }

  export type BookSubjectCreateWithoutSubjectInput = {
    book: BookCreateNestedOneWithoutBookSubjectsInput
  }

  export type BookSubjectUncheckedCreateWithoutSubjectInput = {
    id?: number
    bookId: string
  }

  export type BookSubjectCreateOrConnectWithoutSubjectInput = {
    where: BookSubjectWhereUniqueInput
    create: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type BookSubjectCreateManySubjectInputEnvelope = {
    data: BookSubjectCreateManySubjectInput | BookSubjectCreateManySubjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSubjectsInput = {
    update: XOR<UserUpdateWithoutSubjectsInput, UserUncheckedUpdateWithoutSubjectsInput>
    create: XOR<UserCreateWithoutSubjectsInput, UserUncheckedCreateWithoutSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubjectsInput, UserUncheckedUpdateWithoutSubjectsInput>
  }

  export type UserUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BranchUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutSubjectsInput, BranchUncheckedUpdateWithoutSubjectsInput>
    create: XOR<BranchCreateWithoutSubjectsInput, BranchUncheckedCreateWithoutSubjectsInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutSubjectsInput, BranchUncheckedUpdateWithoutSubjectsInput>
  }

  export type BranchUpdateManyWithWhereWithoutSubjectsInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type BranchScalarWhereInput = {
    AND?: BranchScalarWhereInput | BranchScalarWhereInput[]
    OR?: BranchScalarWhereInput[]
    NOT?: BranchScalarWhereInput | BranchScalarWhereInput[]
    id?: IntFilter<"Branch"> | number
    name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    createdAt?: DateTimeFilter<"Branch"> | Date | string
  }

  export type AcademicYearUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: AcademicYearWhereUniqueInput
    update: XOR<AcademicYearUpdateWithoutSubjectsInput, AcademicYearUncheckedUpdateWithoutSubjectsInput>
    create: XOR<AcademicYearCreateWithoutSubjectsInput, AcademicYearUncheckedCreateWithoutSubjectsInput>
  }

  export type AcademicYearUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: AcademicYearWhereUniqueInput
    data: XOR<AcademicYearUpdateWithoutSubjectsInput, AcademicYearUncheckedUpdateWithoutSubjectsInput>
  }

  export type AcademicYearUpdateManyWithWhereWithoutSubjectsInput = {
    where: AcademicYearScalarWhereInput
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type AcademicYearScalarWhereInput = {
    AND?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    OR?: AcademicYearScalarWhereInput[]
    NOT?: AcademicYearScalarWhereInput | AcademicYearScalarWhereInput[]
    id?: IntFilter<"AcademicYear"> | number
    label?: StringFilter<"AcademicYear"> | string
    code?: StringFilter<"AcademicYear"> | string
  }

  export type UserUpsertWithoutCreatedSubjectsInput = {
    update: XOR<UserUpdateWithoutCreatedSubjectsInput, UserUncheckedUpdateWithoutCreatedSubjectsInput>
    create: XOR<UserCreateWithoutCreatedSubjectsInput, UserUncheckedCreateWithoutCreatedSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedSubjectsInput, UserUncheckedUpdateWithoutCreatedSubjectsInput>
  }

  export type UserUpdateWithoutCreatedSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedSubjectsInput = {
    update: XOR<UserUpdateWithoutUpdatedSubjectsInput, UserUncheckedUpdateWithoutUpdatedSubjectsInput>
    create: XOR<UserCreateWithoutUpdatedSubjectsInput, UserUncheckedCreateWithoutUpdatedSubjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedSubjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedSubjectsInput, UserUncheckedUpdateWithoutUpdatedSubjectsInput>
  }

  export type UserUpdateWithoutUpdatedSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type ChapterUpsertWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
    create: XOR<ChapterCreateWithoutSubjectInput, ChapterUncheckedCreateWithoutSubjectInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutSubjectInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutSubjectInput, ChapterUncheckedUpdateWithoutSubjectInput>
  }

  export type ChapterUpdateManyWithWhereWithoutSubjectInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutSubjectInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: StringFilter<"Chapter"> | string
    title?: StringFilter<"Chapter"> | string
    content?: StringNullableFilter<"Chapter"> | string | null
    subjectId?: StringFilter<"Chapter"> | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type BookUpsertWithWhereUniqueWithoutSubjectsInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutSubjectsInput, BookUncheckedUpdateWithoutSubjectsInput>
    create: XOR<BookCreateWithoutSubjectsInput, BookUncheckedCreateWithoutSubjectsInput>
  }

  export type BookUpdateWithWhereUniqueWithoutSubjectsInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutSubjectsInput, BookUncheckedUpdateWithoutSubjectsInput>
  }

  export type BookUpdateManyWithWhereWithoutSubjectsInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutSubjectsInput>
  }

  export type BookSubjectUpsertWithWhereUniqueWithoutSubjectInput = {
    where: BookSubjectWhereUniqueInput
    update: XOR<BookSubjectUpdateWithoutSubjectInput, BookSubjectUncheckedUpdateWithoutSubjectInput>
    create: XOR<BookSubjectCreateWithoutSubjectInput, BookSubjectUncheckedCreateWithoutSubjectInput>
  }

  export type BookSubjectUpdateWithWhereUniqueWithoutSubjectInput = {
    where: BookSubjectWhereUniqueInput
    data: XOR<BookSubjectUpdateWithoutSubjectInput, BookSubjectUncheckedUpdateWithoutSubjectInput>
  }

  export type BookSubjectUpdateManyWithWhereWithoutSubjectInput = {
    where: BookSubjectScalarWhereInput
    data: XOR<BookSubjectUpdateManyMutationInput, BookSubjectUncheckedUpdateManyWithoutSubjectInput>
  }

  export type BookCreateWithoutBookSubjectsInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
  }

  export type BookUncheckedCreateWithoutBookSubjectsInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
  }

  export type BookCreateOrConnectWithoutBookSubjectsInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutBookSubjectsInput, BookUncheckedCreateWithoutBookSubjectsInput>
  }

  export type SubjectCreateWithoutBookSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectUncheckedCreateWithoutBookSubjectsInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
  }

  export type SubjectCreateOrConnectWithoutBookSubjectsInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutBookSubjectsInput, SubjectUncheckedCreateWithoutBookSubjectsInput>
  }

  export type BookUpsertWithoutBookSubjectsInput = {
    update: XOR<BookUpdateWithoutBookSubjectsInput, BookUncheckedUpdateWithoutBookSubjectsInput>
    create: XOR<BookCreateWithoutBookSubjectsInput, BookUncheckedCreateWithoutBookSubjectsInput>
    where?: BookWhereInput
  }

  export type BookUpdateToOneWithWhereWithoutBookSubjectsInput = {
    where?: BookWhereInput
    data: XOR<BookUpdateWithoutBookSubjectsInput, BookUncheckedUpdateWithoutBookSubjectsInput>
  }

  export type BookUpdateWithoutBookSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
  }

  export type BookUncheckedUpdateWithoutBookSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
  }

  export type SubjectUpsertWithoutBookSubjectsInput = {
    update: XOR<SubjectUpdateWithoutBookSubjectsInput, SubjectUncheckedUpdateWithoutBookSubjectsInput>
    create: XOR<SubjectCreateWithoutBookSubjectsInput, SubjectUncheckedCreateWithoutBookSubjectsInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutBookSubjectsInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutBookSubjectsInput, SubjectUncheckedUpdateWithoutBookSubjectsInput>
  }

  export type SubjectUpdateWithoutBookSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
  }

  export type SubjectUncheckedUpdateWithoutBookSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutSentNotificationsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutSentNotificationsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutSentNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutSentNotificationsInput = {
    update: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
    create: XOR<UserCreateWithoutSentNotificationsInput, UserUncheckedCreateWithoutSentNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentNotificationsInput, UserUncheckedUpdateWithoutSentNotificationsInput>
  }

  export type UserUpdateWithoutSentNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SubjectCreateWithoutChaptersInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutChaptersInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutChaptersInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
  }

  export type SubjectUpsertWithoutChaptersInput = {
    update: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
    create: XOR<SubjectCreateWithoutChaptersInput, SubjectUncheckedCreateWithoutChaptersInput>
    where?: SubjectWhereInput
  }

  export type SubjectUpdateToOneWithWhereWithoutChaptersInput = {
    where?: SubjectWhereInput
    data: XOR<SubjectUpdateWithoutChaptersInput, SubjectUncheckedUpdateWithoutChaptersInput>
  }

  export type SubjectUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutChaptersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type UserCreateWithoutAddedQRCodesInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddedQRCodesInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddedQRCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedQRCodesInput, UserUncheckedCreateWithoutAddedQRCodesInput>
  }

  export type UserCreateWithoutCreatedQRCodesInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutCreatedQRCodesInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutCreatedQRCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedQRCodesInput, UserUncheckedCreateWithoutCreatedQRCodesInput>
  }

  export type UserCreateWithoutUpdatedQRCodesInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedQRCodesInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedQRCodesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedQRCodesInput, UserUncheckedCreateWithoutUpdatedQRCodesInput>
  }

  export type RedirectCreateWithoutQrCodeInput = {
    redirect: string
  }

  export type RedirectUncheckedCreateWithoutQrCodeInput = {
    id?: number
    redirect: string
  }

  export type RedirectCreateOrConnectWithoutQrCodeInput = {
    where: RedirectWhereUniqueInput
    create: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput>
  }

  export type RedirectCreateManyQrCodeInputEnvelope = {
    data: RedirectCreateManyQrCodeInput | RedirectCreateManyQrCodeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddedQRCodesInput = {
    update: XOR<UserUpdateWithoutAddedQRCodesInput, UserUncheckedUpdateWithoutAddedQRCodesInput>
    create: XOR<UserCreateWithoutAddedQRCodesInput, UserUncheckedCreateWithoutAddedQRCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddedQRCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddedQRCodesInput, UserUncheckedUpdateWithoutAddedQRCodesInput>
  }

  export type UserUpdateWithoutAddedQRCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedQRCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutCreatedQRCodesInput = {
    update: XOR<UserUpdateWithoutCreatedQRCodesInput, UserUncheckedUpdateWithoutCreatedQRCodesInput>
    create: XOR<UserCreateWithoutCreatedQRCodesInput, UserUncheckedCreateWithoutCreatedQRCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedQRCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedQRCodesInput, UserUncheckedUpdateWithoutCreatedQRCodesInput>
  }

  export type UserUpdateWithoutCreatedQRCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedQRCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedQRCodesInput = {
    update: XOR<UserUpdateWithoutUpdatedQRCodesInput, UserUncheckedUpdateWithoutUpdatedQRCodesInput>
    create: XOR<UserCreateWithoutUpdatedQRCodesInput, UserUncheckedCreateWithoutUpdatedQRCodesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedQRCodesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedQRCodesInput, UserUncheckedUpdateWithoutUpdatedQRCodesInput>
  }

  export type UserUpdateWithoutUpdatedQRCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedQRCodesInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type RedirectUpsertWithWhereUniqueWithoutQrCodeInput = {
    where: RedirectWhereUniqueInput
    update: XOR<RedirectUpdateWithoutQrCodeInput, RedirectUncheckedUpdateWithoutQrCodeInput>
    create: XOR<RedirectCreateWithoutQrCodeInput, RedirectUncheckedCreateWithoutQrCodeInput>
  }

  export type RedirectUpdateWithWhereUniqueWithoutQrCodeInput = {
    where: RedirectWhereUniqueInput
    data: XOR<RedirectUpdateWithoutQrCodeInput, RedirectUncheckedUpdateWithoutQrCodeInput>
  }

  export type RedirectUpdateManyWithWhereWithoutQrCodeInput = {
    where: RedirectScalarWhereInput
    data: XOR<RedirectUpdateManyMutationInput, RedirectUncheckedUpdateManyWithoutQrCodeInput>
  }

  export type RedirectScalarWhereInput = {
    AND?: RedirectScalarWhereInput | RedirectScalarWhereInput[]
    OR?: RedirectScalarWhereInput[]
    NOT?: RedirectScalarWhereInput | RedirectScalarWhereInput[]
    id?: IntFilter<"Redirect"> | number
    qrCodeId?: StringFilter<"Redirect"> | string
    redirect?: StringFilter<"Redirect"> | string
  }

  export type QRCodeCreateWithoutRedirectsInput = {
    qrCode: string
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
    addedBy: UserCreateNestedOneWithoutAddedQRCodesInput
    createdBy?: UserCreateNestedOneWithoutCreatedQRCodesInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedQRCodesInput
  }

  export type QRCodeUncheckedCreateWithoutRedirectsInput = {
    qrCode: string
    addedById: number
    createdById?: number | null
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QRCodeCreateOrConnectWithoutRedirectsInput = {
    where: QRCodeWhereUniqueInput
    create: XOR<QRCodeCreateWithoutRedirectsInput, QRCodeUncheckedCreateWithoutRedirectsInput>
  }

  export type QRCodeUpsertWithoutRedirectsInput = {
    update: XOR<QRCodeUpdateWithoutRedirectsInput, QRCodeUncheckedUpdateWithoutRedirectsInput>
    create: XOR<QRCodeCreateWithoutRedirectsInput, QRCodeUncheckedCreateWithoutRedirectsInput>
    where?: QRCodeWhereInput
  }

  export type QRCodeUpdateToOneWithWhereWithoutRedirectsInput = {
    where?: QRCodeWhereInput
    data: XOR<QRCodeUpdateWithoutRedirectsInput, QRCodeUncheckedUpdateWithoutRedirectsInput>
  }

  export type QRCodeUpdateWithoutRedirectsInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutAddedQRCodesNestedInput
    createdBy?: UserUpdateOneWithoutCreatedQRCodesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedQRCodesNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutRedirectsInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookCreateWithoutAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    branch?: BranchCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutAcademicYearInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput>
  }

  export type BookCreateManyAcademicYearInputEnvelope = {
    data: BookCreateManyAcademicYearInput | BookCreateManyAcademicYearInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    branch?: BranchCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutAcademicYearInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    branch?: BranchUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutAcademicYearInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput>
  }

  export type BranchCreateWithoutYearsInput = {
    name: string
    location?: string | null
    createdAt?: Date | string
    users?: UserCreateNestedManyWithoutBranchInput
    books?: BookCreateNestedManyWithoutBranchInput
    subjects?: SubjectCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutYearsInput = {
    id?: number
    name: string
    location?: string | null
    createdAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutBranchInput
    books?: BookUncheckedCreateNestedManyWithoutBranchInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutYearsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput>
  }

  export type BookUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutAcademicYearInput, BookUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<BookCreateWithoutAcademicYearInput, BookUncheckedCreateWithoutAcademicYearInput>
  }

  export type BookUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutAcademicYearInput, BookUncheckedUpdateWithoutAcademicYearInput>
  }

  export type BookUpdateManyWithWhereWithoutAcademicYearInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutAcademicYearInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutAcademicYearInput, SubjectUncheckedUpdateWithoutAcademicYearInput>
    create: XOR<SubjectCreateWithoutAcademicYearInput, SubjectUncheckedCreateWithoutAcademicYearInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutAcademicYearInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutAcademicYearInput, SubjectUncheckedUpdateWithoutAcademicYearInput>
  }

  export type SubjectUpdateManyWithWhereWithoutAcademicYearInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutAcademicYearInput>
  }

  export type BranchUpsertWithWhereUniqueWithoutYearsInput = {
    where: BranchWhereUniqueInput
    update: XOR<BranchUpdateWithoutYearsInput, BranchUncheckedUpdateWithoutYearsInput>
    create: XOR<BranchCreateWithoutYearsInput, BranchUncheckedCreateWithoutYearsInput>
  }

  export type BranchUpdateWithWhereUniqueWithoutYearsInput = {
    where: BranchWhereUniqueInput
    data: XOR<BranchUpdateWithoutYearsInput, BranchUncheckedUpdateWithoutYearsInput>
  }

  export type BranchUpdateManyWithWhereWithoutYearsInput = {
    where: BranchScalarWhereInput
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyWithoutYearsInput>
  }

  export type AcademicYearCreateWithoutBranchsInput = {
    label: string
    code: string
    books?: BookCreateNestedManyWithoutAcademicYearInput
    subjects?: SubjectCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearUncheckedCreateWithoutBranchsInput = {
    id?: number
    label: string
    code: string
    books?: BookUncheckedCreateNestedManyWithoutAcademicYearInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutAcademicYearInput
  }

  export type AcademicYearCreateOrConnectWithoutBranchsInput = {
    where: AcademicYearWhereUniqueInput
    create: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput>
  }

  export type UserCreateWithoutBranchInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutBranchInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutBranchInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserCreateManyBranchInputEnvelope = {
    data: UserCreateManyBranchInput | UserCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type BookCreateWithoutBranchInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBooksInput
    academicYear?: AcademicYearCreateNestedOneWithoutBooksInput
    createdBy?: UserCreateNestedOneWithoutCreatedBooksInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedBooksInput
    subjects?: SubjectCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutBookInput
  }

  export type BookUncheckedCreateWithoutBranchInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    subjects?: SubjectUncheckedCreateNestedManyWithoutBooksInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutBookInput
  }

  export type BookCreateOrConnectWithoutBranchInput = {
    where: BookWhereUniqueInput
    create: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput>
  }

  export type BookCreateManyBranchInputEnvelope = {
    data: BookCreateManyBranchInput | BookCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SubjectCreateWithoutBranchInput = {
    id?: string
    name: string
    description?: string | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSubjectsInput
    academicYear?: AcademicYearCreateNestedManyWithoutSubjectsInput
    createdBy?: UserCreateNestedOneWithoutCreatedSubjectsInput
    updatedBy?: UserCreateNestedOneWithoutUpdatedSubjectsInput
    chapters?: ChapterCreateNestedManyWithoutSubjectInput
    books?: BookCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectCreateNestedManyWithoutSubjectInput
  }

  export type SubjectUncheckedCreateWithoutBranchInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    academicYear?: AcademicYearUncheckedCreateNestedManyWithoutSubjectsInput
    chapters?: ChapterUncheckedCreateNestedManyWithoutSubjectInput
    books?: BookUncheckedCreateNestedManyWithoutSubjectsInput
    bookSubjects?: BookSubjectUncheckedCreateNestedManyWithoutSubjectInput
  }

  export type SubjectCreateOrConnectWithoutBranchInput = {
    where: SubjectWhereUniqueInput
    create: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput>
  }

  export type AcademicYearUpsertWithWhereUniqueWithoutBranchsInput = {
    where: AcademicYearWhereUniqueInput
    update: XOR<AcademicYearUpdateWithoutBranchsInput, AcademicYearUncheckedUpdateWithoutBranchsInput>
    create: XOR<AcademicYearCreateWithoutBranchsInput, AcademicYearUncheckedCreateWithoutBranchsInput>
  }

  export type AcademicYearUpdateWithWhereUniqueWithoutBranchsInput = {
    where: AcademicYearWhereUniqueInput
    data: XOR<AcademicYearUpdateWithoutBranchsInput, AcademicYearUncheckedUpdateWithoutBranchsInput>
  }

  export type AcademicYearUpdateManyWithWhereWithoutBranchsInput = {
    where: AcademicYearScalarWhereInput
    data: XOR<AcademicYearUpdateManyMutationInput, AcademicYearUncheckedUpdateManyWithoutBranchsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
    create: XOR<UserCreateWithoutBranchInput, UserUncheckedCreateWithoutBranchInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBranchInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBranchInput, UserUncheckedUpdateWithoutBranchInput>
  }

  export type UserUpdateManyWithWhereWithoutBranchInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBranchInput>
  }

  export type BookUpsertWithWhereUniqueWithoutBranchInput = {
    where: BookWhereUniqueInput
    update: XOR<BookUpdateWithoutBranchInput, BookUncheckedUpdateWithoutBranchInput>
    create: XOR<BookCreateWithoutBranchInput, BookUncheckedCreateWithoutBranchInput>
  }

  export type BookUpdateWithWhereUniqueWithoutBranchInput = {
    where: BookWhereUniqueInput
    data: XOR<BookUpdateWithoutBranchInput, BookUncheckedUpdateWithoutBranchInput>
  }

  export type BookUpdateManyWithWhereWithoutBranchInput = {
    where: BookScalarWhereInput
    data: XOR<BookUpdateManyMutationInput, BookUncheckedUpdateManyWithoutBranchInput>
  }

  export type SubjectUpsertWithWhereUniqueWithoutBranchInput = {
    where: SubjectWhereUniqueInput
    update: XOR<SubjectUpdateWithoutBranchInput, SubjectUncheckedUpdateWithoutBranchInput>
    create: XOR<SubjectCreateWithoutBranchInput, SubjectUncheckedCreateWithoutBranchInput>
  }

  export type SubjectUpdateWithWhereUniqueWithoutBranchInput = {
    where: SubjectWhereUniqueInput
    data: XOR<SubjectUpdateWithoutBranchInput, SubjectUncheckedUpdateWithoutBranchInput>
  }

  export type SubjectUpdateManyWithWhereWithoutBranchInput = {
    where: SubjectScalarWhereInput
    data: XOR<SubjectUpdateManyMutationInput, SubjectUncheckedUpdateManyWithoutBranchInput>
  }

  export type UserCreateWithoutAddedWhiteListedUrlsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddedWhiteListedUrlsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddedWhiteListedUrlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedWhiteListedUrlsInput, UserUncheckedCreateWithoutAddedWhiteListedUrlsInput>
  }

  export type UserCreateWithoutUpdatedWhiteListedUrlsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedWhiteListedUrlsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedWhiteListedUrlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedCreateWithoutUpdatedWhiteListedUrlsInput>
  }

  export type UserUpsertWithoutAddedWhiteListedUrlsInput = {
    update: XOR<UserUpdateWithoutAddedWhiteListedUrlsInput, UserUncheckedUpdateWithoutAddedWhiteListedUrlsInput>
    create: XOR<UserCreateWithoutAddedWhiteListedUrlsInput, UserUncheckedCreateWithoutAddedWhiteListedUrlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddedWhiteListedUrlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddedWhiteListedUrlsInput, UserUncheckedUpdateWithoutAddedWhiteListedUrlsInput>
  }

  export type UserUpdateWithoutAddedWhiteListedUrlsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedWhiteListedUrlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedWhiteListedUrlsInput = {
    update: XOR<UserUpdateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedUpdateWithoutUpdatedWhiteListedUrlsInput>
    create: XOR<UserCreateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedCreateWithoutUpdatedWhiteListedUrlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedWhiteListedUrlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedWhiteListedUrlsInput, UserUncheckedUpdateWithoutUpdatedWhiteListedUrlsInput>
  }

  export type UserUpdateWithoutUpdatedWhiteListedUrlsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedWhiteListedUrlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type UserCreateWithoutAddedBlockedUrlsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAddedBlockedUrlsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAddedBlockedUrlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddedBlockedUrlsInput, UserUncheckedCreateWithoutAddedBlockedUrlsInput>
  }

  export type UserCreateWithoutUpdatedBlockedUrlsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedBlockedUrlsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    updatedSettings?: SettingsUncheckedCreateNestedManyWithoutUpdatedByInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedBlockedUrlsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedBlockedUrlsInput, UserUncheckedCreateWithoutUpdatedBlockedUrlsInput>
  }

  export type UserUpsertWithoutAddedBlockedUrlsInput = {
    update: XOR<UserUpdateWithoutAddedBlockedUrlsInput, UserUncheckedUpdateWithoutAddedBlockedUrlsInput>
    create: XOR<UserCreateWithoutAddedBlockedUrlsInput, UserUncheckedCreateWithoutAddedBlockedUrlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddedBlockedUrlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddedBlockedUrlsInput, UserUncheckedUpdateWithoutAddedBlockedUrlsInput>
  }

  export type UserUpdateWithoutAddedBlockedUrlsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedBlockedUrlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUpsertWithoutUpdatedBlockedUrlsInput = {
    update: XOR<UserUpdateWithoutUpdatedBlockedUrlsInput, UserUncheckedUpdateWithoutUpdatedBlockedUrlsInput>
    create: XOR<UserCreateWithoutUpdatedBlockedUrlsInput, UserUncheckedCreateWithoutUpdatedBlockedUrlsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedBlockedUrlsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedBlockedUrlsInput, UserUncheckedUpdateWithoutUpdatedBlockedUrlsInput>
  }

  export type UserUpdateWithoutUpdatedBlockedUrlsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedBlockedUrlsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserCreateWithoutUpdatedSettingsInput = {
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    role?: UserRoleCreateNestedOneWithoutUsersInput
    branch?: BranchCreateNestedOneWithoutUsersInput
    createdBooks?: BookCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookCreateNestedManyWithoutUpdatedByInput
    books?: BookCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeCreateNestedManyWithoutAddedByInput
    addedBy?: UserCreateNestedOneWithoutAddedUsersInput
    addedUsers?: UserCreateNestedManyWithoutAddedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationCreateNestedManyWithoutSenderInput
    addedBlockedUrls?: BlockedUrlCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutUpdatedSettingsInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
    createdBooks?: BookUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBooks?: BookUncheckedCreateNestedManyWithoutUpdatedByInput
    books?: BookUncheckedCreateNestedManyWithoutUserInput
    createdSubjects?: SubjectUncheckedCreateNestedManyWithoutCreatedByInput
    updatedSubjects?: SubjectUncheckedCreateNestedManyWithoutUpdatedByInput
    subjects?: SubjectUncheckedCreateNestedManyWithoutUserInput
    createdQRCodes?: QRCodeUncheckedCreateNestedManyWithoutCreatedByInput
    updatedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutUpdatedByInput
    addedQRCodes?: QRCodeUncheckedCreateNestedManyWithoutAddedByInput
    addedUsers?: UserUncheckedCreateNestedManyWithoutAddedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    sentNotifications?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    addedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedBlockedUrls?: BlockedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutCreatedByInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutUpdatedSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
  }

  export type UserUpsertWithoutUpdatedSettingsInput = {
    update: XOR<UserUpdateWithoutUpdatedSettingsInput, UserUncheckedUpdateWithoutUpdatedSettingsInput>
    create: XOR<UserCreateWithoutUpdatedSettingsInput, UserUncheckedCreateWithoutUpdatedSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUpdatedSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUpdatedSettingsInput, UserUncheckedUpdateWithoutUpdatedSettingsInput>
  }

  export type UserUpdateWithoutUpdatedSettingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutUpdatedSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type BookCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateManyUpdatedByInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    branchId?: number | null
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyUpdatedByInput = {
    id?: string
    name: string
    description?: string | null
    userId: number
    createdById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubjectCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QRCodeCreateManyCreatedByInput = {
    qrCode: string
    addedById: number
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QRCodeCreateManyUpdatedByInput = {
    qrCode: string
    addedById: number
    createdById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QRCodeCreateManyAddedByInput = {
    qrCode: string
    createdById?: number | null
    updatedById?: number | null
    qrContent: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyAddedByInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type NotificationCreateManyRecipientInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    senderId?: number | null
    createdAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: number
    title: string
    message: string
    isRead?: boolean
    recipientId: number
    createdAt?: Date | string
  }

  export type SettingsCreateManyUpdatedByInput = {
    id?: number
    key: string
    value: string
    type: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type BlockedUrlCreateManyCreatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: number | null
  }

  export type BlockedUrlCreateManyUpdatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type WhitelistedUrlCreateManyCreatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedById?: number | null
  }

  export type WhitelistedUrlCreateManyUpdatedByInput = {
    id?: number
    url: string
    domain: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
  }

  export type BookUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUpdateWithoutCreatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutAddedQRCodesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedQRCodesNestedInput
    redirects?: RedirectUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutCreatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redirects?: RedirectUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateManyWithoutCreatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUpdateWithoutUpdatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: UserUpdateOneRequiredWithoutAddedQRCodesNestedInput
    createdBy?: UserUpdateOneWithoutCreatedQRCodesNestedInput
    redirects?: RedirectUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutUpdatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redirects?: RedirectUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateManyWithoutUpdatedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    addedById?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QRCodeUpdateWithoutAddedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedQRCodesNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedQRCodesNestedInput
    redirects?: RedirectUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateWithoutAddedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    redirects?: RedirectUncheckedUpdateManyWithoutQrCodeNestedInput
  }

  export type QRCodeUncheckedUpdateManyWithoutAddedByInput = {
    qrCode?: StringFieldUpdateOperationsInput | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    qrContent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutAddedByInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutAddedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUpdateWithoutRecipientInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneWithoutSentNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    senderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    recipientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUpdateWithoutUpdatedByInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SettingsUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlUpdateWithoutCreatedByInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutUpdatedBlockedUrlsNestedInput
  }

  export type BlockedUrlUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlUpdateWithoutUpdatedByInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAddedBlockedUrlsNestedInput
  }

  export type BlockedUrlUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlockedUrlUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhitelistedUrlUpdateWithoutCreatedByInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutUpdatedWhiteListedUrlsNestedInput
  }

  export type WhitelistedUrlUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhitelistedUrlUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhitelistedUrlUpdateWithoutUpdatedByInput = {
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutAddedWhiteListedUrlsNestedInput
  }

  export type WhitelistedUrlUncheckedUpdateWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateManyRoleInput = {
    id?: number
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    branchId?: number | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type UserUpdateWithoutRoleInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    branch?: BranchUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PermissionUpdateWithoutRolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateWithoutRolesInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PermissionUncheckedUpdateManyWithoutRolesInput = {
    permissionId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    permissionCode?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleUpdateWithoutPermissionsInput = {
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutPermissionsInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutPermissionsInput = {
    roleId?: IntFieldUpdateOperationsInput | number
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type BookSubjectCreateManyBookInput = {
    id?: number
    subjectId: string
  }

  export type SubjectUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutBooksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSubjectUpdateWithoutBookInput = {
    subject?: SubjectUpdateOneRequiredWithoutBookSubjectsNestedInput
  }

  export type BookSubjectUncheckedUpdateWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type BookSubjectUncheckedUpdateManyWithoutBookInput = {
    id?: IntFieldUpdateOperationsInput | number
    subjectId?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterCreateManySubjectInput = {
    id?: string
    title: string
    content?: string | null
    createdAt?: Date | string
  }

  export type BookSubjectCreateManySubjectInput = {
    id?: number
    bookId: string
  }

  export type BranchUpdateWithoutSubjectsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUpdateManyWithoutBranchsNestedInput
    users?: UserUpdateManyWithoutBranchNestedInput
    books?: BookUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    years?: AcademicYearUncheckedUpdateManyWithoutBranchsNestedInput
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    books?: BookUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicYearUpdateWithoutSubjectsInput = {
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUpdateManyWithoutYearsNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUncheckedUpdateManyWithoutAcademicYearNestedInput
    branchs?: BranchUncheckedUpdateManyWithoutYearsNestedInput
  }

  export type AcademicYearUncheckedUpdateManyWithoutSubjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyWithoutSubjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutSubjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookSubjectUpdateWithoutSubjectInput = {
    book?: BookUpdateOneRequiredWithoutBookSubjectsNestedInput
  }

  export type BookSubjectUncheckedUpdateWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type BookSubjectUncheckedUpdateManyWithoutSubjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookId?: StringFieldUpdateOperationsInput | string
  }

  export type RedirectCreateManyQrCodeInput = {
    id?: number
    redirect: string
  }

  export type RedirectUpdateWithoutQrCodeInput = {
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type RedirectUncheckedUpdateWithoutQrCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type RedirectUncheckedUpdateManyWithoutQrCodeInput = {
    id?: IntFieldUpdateOperationsInput | number
    redirect?: StringFieldUpdateOperationsInput | string
  }

  export type BookCreateManyAcademicYearInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    branchId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    branch?: BranchUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    branchId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    branch?: BranchUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutAcademicYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUpdateWithoutYearsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutBranchNestedInput
    books?: BookUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutBranchNestedInput
    books?: BookUncheckedUpdateManyWithoutBranchNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateManyWithoutYearsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyBranchInput = {
    id?: number
    roleId?: number | null
    name: string
    email?: string | null
    phone: string
    password: string
    activeStatus: boolean
    joiningDate?: Date | string | null
    fcmToken?: string | null
    addedById?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById?: number | null
    updatedById?: number | null
  }

  export type BookCreateManyBranchInput = {
    id?: string
    title: string
    description?: string | null
    publisher?: string | null
    userId: number
    academicYearId?: number | null
    createdById?: number | null
    updatedById?: number | null
    deletedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicYearUpdateWithoutBranchsInput = {
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUpdateManyWithoutAcademicYearNestedInput
    subjects?: SubjectUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateWithoutBranchsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    books?: BookUncheckedUpdateManyWithoutAcademicYearNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutAcademicYearNestedInput
  }

  export type AcademicYearUncheckedUpdateManyWithoutBranchsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    role?: UserRoleUpdateOneWithoutUsersNestedInput
    createdBooks?: BookUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUpdateManyWithoutUpdatedByNestedInput
    books?: BookUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUpdateManyWithoutAddedByNestedInput
    addedBy?: UserUpdateOneWithoutAddedUsersNestedInput
    addedUsers?: UserUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdBooks?: BookUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBooks?: BookUncheckedUpdateManyWithoutUpdatedByNestedInput
    books?: BookUncheckedUpdateManyWithoutUserNestedInput
    createdSubjects?: SubjectUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedSubjects?: SubjectUncheckedUpdateManyWithoutUpdatedByNestedInput
    subjects?: SubjectUncheckedUpdateManyWithoutUserNestedInput
    createdQRCodes?: QRCodeUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedQRCodes?: QRCodeUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedQRCodes?: QRCodeUncheckedUpdateManyWithoutAddedByNestedInput
    addedUsers?: UserUncheckedUpdateManyWithoutAddedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    sentNotifications?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    updatedSettings?: SettingsUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedBlockedUrls?: BlockedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
    addedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutCreatedByNestedInput
    updatedWhiteListedUrls?: WhitelistedUrlUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    activeStatus?: BoolFieldUpdateOperationsInput | boolean
    joiningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    addedById?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BookUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBooksNestedInput
    academicYear?: AcademicYearUpdateOneWithoutBooksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedBooksNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedBooksNestedInput
    subjects?: SubjectUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subjects?: SubjectUncheckedUpdateManyWithoutBooksNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutBookNestedInput
  }

  export type BookUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    academicYearId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubjectUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubjectsNestedInput
    academicYear?: AcademicYearUpdateManyWithoutSubjectsNestedInput
    createdBy?: UserUpdateOneWithoutCreatedSubjectsNestedInput
    updatedBy?: UserUpdateOneWithoutUpdatedSubjectsNestedInput
    chapters?: ChapterUpdateManyWithoutSubjectNestedInput
    books?: BookUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    academicYear?: AcademicYearUncheckedUpdateManyWithoutSubjectsNestedInput
    chapters?: ChapterUncheckedUpdateManyWithoutSubjectNestedInput
    books?: BookUncheckedUpdateManyWithoutSubjectsNestedInput
    bookSubjects?: BookSubjectUncheckedUpdateManyWithoutSubjectNestedInput
  }

  export type SubjectUncheckedUpdateManyWithoutBranchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdById?: NullableIntFieldUpdateOperationsInput | number | null
    updatedById?: NullableIntFieldUpdateOperationsInput | number | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}